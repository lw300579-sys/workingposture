<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Posture Analysis & Personalized Biomechanics Protocol</title>

    
<!-- React & Dependencies -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<!-- TensorFlow (Lazy Loaded) -->


<style>
    body { background-color: #020617; color: #e2e8f0; font-family: 'Inter', system-ui, sans-serif; overflow: auto; font-size: 16px; }

    .viewport { position: relative; display: flex; flex-direction: column; background: #0f172a; overflow y: auto; overflow-x: hidden; padding: 2rem; min-height: 100vh; }
.glass-panel { 
    background: #020617; 
    border-left: 1px solid #1e293b; 
    height: 100vh; 
    z-index: 40; 
    display: block;      /* Changed from flex to block */
    overflow-y: auto;    /* Enables the whole panel to scroll */
}
    
    .upload-grid { display: grid; grid-template-columns: 1fr; gap: 1.5rem; }
@media (min-width: 768px) {
  .upload-grid { 
        grid-template-columns: repeat(3, 1fr); 
    }
}
    .upload-slot { 
    border: 2px dashed #334155; 
    border-radius: 12px; 
    position: relative; 
    background: rgba(30, 41, 59, 0.3); 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    cursor: pointer; 
    min-height: 300px; /* Forces a minimum size so it's not tiny */
    height: auto!important; 
}
    }
    .upload-slot:hover { border-color: #22d3ee; background: #1e293b/50; }
    .upload-slot.active { border-style: solid; border-color: #22d3ee; }
    .upload-slot img { width: 100%; height: 100%; object-fit: contain; opacity: 0.6; }
    
    .btn-primary { 
    background: #3b82f6; /* Bright "Electric Blue" */
    color: white; 
    font-weight: 900; /* Extra thick text */
    padding: 18px 24px; /* Big enough for a thumb to hit */
    border-radius: 12px; 
    text-transform: uppercase; 
    letter-spacing: 1px; 
    font-size: 14px; 
    display: flex; 
    align-items: center; 
    gap: 8px; 
    justify-content: center; 
    box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); 
    cursor: pointer; 
    width: 100%; 
}}
    .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(6, 182, 212, 0.3); filter: brightness(1.1); }
    .btn-primary:active { 
        transform: translateY(1px); box-shadow: 0 2px 8px rgba(6, 182, 212, 0.2); filter: brightness(0.95); }
    .btn-primary:disabled { opacity: 0.7; cursor: wait; transform: none; }

    .btn-secondary { background: #1e293b; border: 1px solid #334155; color: #94a3b8; font-weight: bold; padding: 16px 24px; border-radius: 8px; transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px; font-size: 12px; cursor: pointer; }
    .btn-secondary:hover { border-color: #64748b; color: white; }

    .protocol-badge { font-size: 9px; padding: 2px 6px; border-radius: 4px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.5px; background: #0f172a; border: 1px solid #334155; color: #94a3b8; cursor: pointer; transition: all 0.2s; }
    .protocol-badge:hover { border-color: #22d3ee; color: #22d3ee; }

    .fascia-tag { font-size: 10px; font-weight: bold; padding: 4px 8px; background: #0f172a; border: 1px solid #334155; border-radius: 4px; color: #94a3b8; display: flex; justify-content: space-between; }
    .symptom-tag { background: #450a0a; border-color: #ef4444; color: #fca5a5; }
    
    .symptom-chip {
        padding: 6px 12px; border-radius: 20px; border: 1px solid #334155; background: #1e293b; color: #94a3b8; 
        font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 6px;
    }
    .symptom-chip:hover { border-color: #64748b; }
    .symptom-chip.selected { background: #f43f5e; border-color: #e11d48; color: white; box-shadow: 0 2px 8px rgba(244, 63, 94, 0.4); }
    
    .tab-btn { padding: 8px 16px; font-size: 11px; font-weight: 700; text-transform: uppercase; color: #64748b; cursor: pointer; transition: all 0.2s; border-bottom: 2px solid transparent; }
    .tab-btn.active { color: #22d3ee; border-bottom-color: #22d3ee; }

    .task-card { background: #1e293b/40; border: 1px solid #334155; border-radius: 8px; padding: 12px; transition: all 0.2s; display: flex; align-items: center; gap: 12px; cursor: pointer; }
    .task-card:hover { border-color: #22d3ee; background: #1e293b/60; }
    .task-card.completed { border-color: #10b981; background: #064e3b/20; }
    .task-check { width: 18px; height: 18px; border-radius: 50%; border: 2px solid #475569; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
    .task-card.completed .task-check { background: #10b981; border-color: #10b981; }

    /* Chat Styles */
    .chat-bubble { padding: 10px 14px; border-radius: 12px; font-size: 12px; line-height: 1.5; max-width: 90%; margin-bottom: 8px; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    .chat-user { background: #0891b2; color: white; align-self: flex-end; border-bottom-right-radius: 2px; margin-left: auto; }
    .chat-ai { background: #1e293b; color: #e2e8f0; align-self: flex-start; border-bottom-left-radius: 2px; border: 1px solid #334155; }
    @keyframes popIn { from { opacity: 0; transform: scale(0.9) translateY(10px); } to { opacity: 1; transform: scale(1) translateY(0); } }
    
    .animate-popIn { animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

    /* Scan Line Animation */
    .scanner-line { position: absolute; left: 0; right: 0; height: 5px; background: #22d3ee; box-shadow: 0 0 15px #22d3ee; animation: scanDown 2s infinite ease-in-out; z-index: 20; display: none; }
    .analyzing .scanner-line { display: block; }
   @keyframes scanDown { 
    0% { top: 0%; opacity: 0; } 
    10% { opacity: 0.8; }  /* Early ramp for smoother start */
    80% { opacity: 1; top: 80%; }  /* Hold high longer */
    90% { opacity: 0.6; top: 95%; }  /* Gradual bottom fade */
    100% { top: 100%; opacity: 0; }  /* Soft land */
}}

    /* Avatar Breathing Animation */
    .body-part { transition: all 0.3s; cursor: pointer; }
    .body-part:hover { filter: brightness(1.3); }
    .living-avatar { animation: breathe 6s ease-in-out infinite; }
    @keyframes breathe { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }
    
    /* Confetti CSS */
    .confetti { position: absolute; width: 8px; height: 8px; background: #22d3ee; animation: confetti-fall 3s linear infinite; opacity: 0; }
    @keyframes confetti-fall {
        0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
        100% { transform: translateY(500px) rotate(720deg); opacity: 0; }
    }

    /* NEW: Progress Streak Styles */
    .streak-flame { animation: flicker 2s infinite alternate; }
    @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }

    /* NEW: Goal Tracker Styles */
    .goal-progress { background: linear-gradient(to right, #10b981, #059669); height: 4px; border-radius: 2px; transition: width 0.3s ease; }

    @media print {
        body { background: white; color: black; overflow: visible; }
        .workspace { display: flex; height: auto; }
        .viewport, .glass-panel { width: 100%; height: auto; border: none; overflow: visible; }
        .upload-grid { display: grid; grid-template-columns: repeat(3, 1fr); height: 200px; margin-bottom: 2rem; }
        .upload-slot { border: 1px solid #ccc; background: white; }
        .upload-slot img { opacity: 1; }
        .no-print { display: none !important; }
        .text-white { color: black@media (max-width: 768px) {
    .workspace {
        display: flex;
        flex-direction: column;
	min-height: 100vh; 
    	overflow-x: hidden;
    }
     @media (min-width: 1024px) {
   	.workspace { 
        display: grid; 
        grid-template-columns: 1fr 450px; 
        height: 100vh; 
    }
}
    .viewport { 
    position: relative; 
    display: flex; 
    flex-direction: column; 
    background: #0f172a; 
    padding: 1rem; /* Smaller padding for small screens */
    min-height: auto;
    }
    .glass-panel {
        height: auto;
        max-height: 50vh;
        border-left: none;
        border-top: 1px solid #1e293b; !important; }
        .text-slate-500 { color: #666 !important; }
        .bg-slate-900\/50 { background: none !important; border: 1px solid #eee; }
        .protocol-badge { border: 1px solid #000; color: #000; }
    }
</style></head>
<body>
    <div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    // --- ICONS ---
    const Icons = {
        Plus: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>,
        Check: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M20 6 9 17l-5-5"/></svg>,
        Scan: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2"/><path d="M17 3h2a2 2 0 0 1 2 2v2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M7 21H5a2 2 0 0 1-2-2v-2"/><circle cx="12" cy="12" r="1"/><path d="M5 12h2"/><path d="M17 12h2"/><path d="M12 5v2"/><path d="M12 17v2"/></svg>,
        Video: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>,
        Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
        Pause: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>,
        List: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>,
        Close: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18"/><path d="M6 6 18 18"/></svg>,
        Print: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></svg>,
        History: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>,
        Trash: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>,
        Speaker: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>,
        Info: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>,
        Book: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
        Sun: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>,
        Moon: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>,
        Award: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="8" r="7"/><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"/></svg>,
        Send: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>,
        Layers: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>,
        ArrowUp: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="19" x2="12" y2="5"/><polyline points="5 12 12 5 19 12"/></svg>,
        ArrowDown: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><polyline points="19 12 12 19 5 12"/></svg>,
        Share: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>,
        Music: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>,
        Target: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>,
        Flame: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/></svg>,
	Camera: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>,
    };

    const ACADEMY = [
        {
            title: "The Three Planes",
            subtitle: "The Geometry of Power",
            author: "Clinical Analysis",
            desc: "True athletic power isn't built in a single line. It requires mastery of the Sagittal, Frontal, and Transverse planes. Most traditional training fails because it ignores the Transverse (Rotational) plane, which is the key to athletic function.",
            sections: [
                { head: "The 3 Planes Defined", body: "1. Sagittal (Forward/Back): Flexion and extension. Examples: Lunges, Bicep Curls. 2. Frontal (Side/Side): Abduction and adduction. Examples: Lateral Lunges, Side Shuffles. 3. Transverse (Rotation): Twisting the torso and hips. Examples: Throwing, Punching, Walking." },
                { head: "Core Reality: Stabilization", body: "The core is designed to transfer force, not create it. Its primary role is 'Anti-Rotation,' which prevents the spine from crumpling under load before it can safely produce 'Rotation'. Traditional crunches are an example of only training flexion (Sagittal), and ignoring the core's true 3D function." },
                { head: "The Lumbar Conflict", body: "The lumbar spine (lower back) only has about 13 degrees of rotation available. Forcing it to twist leads to injury. We have to train the hips and thoracic spine (upper back) to rotate powerfully while the core braces to protect the lower back. That's why we prioritize 'Anti-Rotation' first." }
            ],
            key_terms: ["Sagittal Plane", "Frontal Plane", "Transverse Plane", "Anti-Rotation"],
            color: "from-indigo-600 to-purple-600"
        },
        {
            title: "WeckMethod Rotational Power",
            subtitle: "The Science of Coiling",
            author: "David Weck",
            desc: "Human power is rotational. The WeckMethod focuses on 'Coiling,' which is the ability to spiral the torso and align the head over the foot to maximize fascial tension and balance.",
            sections: [
                { head: "Coiling vs Bracing", body: "Most traditional training teaches a stiff, braced core. WeckMethod teaches a 'Coiled' core, where the spine side-bends and rotates to create elastic potential energy. This is how elite athletes move naturally." },
                { head: "Head Over Foot", body: "Balance is dictated by the relationship between the head and the foot. By aligning the head directly over the load-bearing foot (Head Over Foot), you unlock the glute and lat connection, creating a powerful 'Royal Coil'." }
            ],
            key_terms: ["Coiling Core", "Head Over Foot", "Royal Coil", "Torsion"],
            color: "from-red-600 to-orange-600"
        },
        {
            title: "Functional Movement",
            subtitle: "The Biomechanics of Gait",
            author: "Clinical Analysis",
            desc: "Muscles don’t work alone, and neither should your training. Here's why a muscle-centric approach fails, and how integrated movement restores strength and coordination that isolated exercises can't.",
            sections: [
                { head: "The Contralateral Engine", body: "Humans are unique in the animal kingdom as bipedal, contralateral movers. When the left leg steps forward, the right arm swings forward. This reciprocal motion creates a torsion force through the torso, loading the 'Slings' of the body like a rubber band. Traditional sagittal plane training (squats, deadlifts) often locks the pelvis and ribcage together, destroying this natural rotation." },
                { head: "Sling System Mechanics", body: "The body is held together by four primary fascial slings. The Anterior Oblique Sling (AOS) connects the external oblique to the opposite inner thigh (adductor). The Posterior Oblique Sling (POS) connects the latissimus dorsi to the opposite glute. Chronic pain is often a symptom of 'Sling Disconnection'—for example, if the Lat can't communicate with the opposite Glute, the lower back (QL) is forced to stabilize the spine alone, leading to spasm and pain." },
                { head: "Decompression & Tensegrity", body: "Gravity is a constant compressive force on the human frame. Most chronic joint pain is simply the result of compression over time. Functional Movement prioritizes 'Tensegrity' (Tensional Integrity)—which is the idea that structures are stabilized by continuous tension rather than continuous compression. By training the body to pull itself apart (Elongation) rather than push itself together (Compression), we create space in the joints and allow for regeneration." }
            ],
            key_terms: ["Contralateral Reciprocation", "Anterior Oblique Sling", "Posterior Oblique Sling", "Tensegrity"],
            color: "from-blue-600 to-cyan-500"
        },
        {
            title: "Hyperarch Fascia",
            subtitle: "The Glute-Foot Connection",
            author: "Chong Xie",
            desc: "The foot is the primary interface with gravity. HFT (Hyperarch Fascia Training) shows that the structural integrity of the foot arch dictates the firing capacity of the entire posterior chain.",
            sections: [
                { head: "The Battery of Human Movement", body: "The plantar fascia is designed to act as a biological spring. In healthy movement, when the foot strikes the ground, the arch should flatten slightly to absorb potential energy, and then recoil instantly to release it. This 'Elastic Recoil' allows for efficient movement. In modern humans, shoes and flat surfaces have weakened this spring, forcing the muscles to do the work of the fascia, leading to fatigue and 'heavy' legs." },
                { head: "The Principle of Heel Suspension", body: "In elite athletes (sprinters, jumpers), the heel rarely touches the ground with full bodyweight. It hovers, keeping the Achilles tendon under constant tension. This state, called the 'Hyperarch,' creates a direct neural connection to the Gluteus Maximus. If the heel collapses, the signal to the glute is lost, and the knee is forced to absorb the impact forces (Patellar Tendonitis). Training with a suspended heel re-wires the brain to prioritize fascial loading." },
                { head: "Sensory Feedback", body: "The foot is a dense sensory organ, second only to the hands. If the intrinsic foot muscles are dormant, the brain turns down the 'volume' on the entire leg's stability. You can't have a strong, reactive posterior chain with a weak, desensitized foot." }
            ],
            key_terms: ["Fascial Recoil", "Heel Suspension", "Kinetic Chain", "Windlass Mechanism"],
            color: "from-emerald-600 to-green-500"
        },
        {
            title: "Knees Over Toes",
            subtitle: "Restoring Structural Integrity",
            author: "Inspired by Ben Patrick | Verified Methodology",
            desc: "Reversing the damage of modern sedentary life by restoring the full range of motion and strength to the knee and hip complex. We're not just managing pain; we are engineering resilience.",
            sections: [
                { head: "The Myth of 'Bad Knees'", body: "For decades, fitness dogma stated \"never let your knees go past your toes.\" This advice effectively de-conditioned the tendons and the VMO (Vastus Medialis Oblique) muscle—the teardrop-shaped stabilizer on the inside of the knee. By avoiding this natural range of motion, we left the knee vulnerable to any force that pushed it into flexion. To build a bulletproof knee, you must progressively load it in its most vulnerable position: full flexion." },
                { head: "Long Range Strength", body: "Sitting for 8 hours a day locks the hip flexors in a shortened position, acting as a constant brake on your movement. The ATG Split Squat is the antidote. It is unique because it strengthens the front leg in deep flexion while simultaneously lengthening the hip flexor of the trailing leg under load. This \"Long Range Strength\" unlocks tight hips, relieves lower back tension, and restores the ability to move through full ranges without compensation." },
                { head: "Synovial Fluid & The Pump Mechanism", body: "Cartilage and tendons have no direct blood supply; they are avascular. They rely entirely on the \"pump\" mechanism of movement to circulate nutrients. Deep compression exercises (like full knee bends) create a pressure gradient that pushes nutrient-rich synovial fluid into the deepest parts of the joint. This facilitates healing from the inside out, turning movement into medicine." },
                { head: "The First Line of Defense: Tibialis Anterior", body: "The knee does not exist in a vacuum. Every step you take sends ground reaction forces up your leg. The Tibialis Anterior (the muscle on the front of your shin) is your primary shock absorber.\n• The Problem: Modern footwear with elevated heels and rigid soles atrophies this muscle, forcing the knee to absorb force it wasn't designed to handle.\n• The Solution: Strengthening the Tibialis (via tibialis raises) creates a \"buffer zone\" for the knee. A strong shin muscle acts as a decelerator for the foot, protecting the knee joint from impact with every stride." },
                { head: "The Posterior Shield: Hamstring Resilience", body: "You cannot have a bulletproof knee with a glass hamstring. While the VMO pushes you out of deep flexion, the hamstrings (specifically the distal tendons behind the knee) must be strong enough to stabilize the joint during extension and deceleration.\n• The Nordic Curl: This movement builds eccentric strength—the ability of the muscle to produce force while lengthening. This is the exact mechanism required to prevent ACL tears. By bulletproofing the back of the knee, you create a structural counter-balance to the forces placed on the front." },
                { head: "Davis’s Law & Structural Timing", body: "Rest does not fix tendinopathy; it only reduces inflammation while the tissue atrophies further. We follow Davis’s Law: soft tissue models itself along imposed demands.\n• Muscle vs. Tendon: Muscles are vascular and heal quickly (days to weeks). Tendons and ligaments are avascular and remodel slowly (months to years).\n• The Trap: Your muscles will get strong faster than your tendons. If you rush the process, your engine will overpower your chassis.\n• The Strategy: Patience is a biomechanical necessity. We use high-repetition, lower-load work to thicken connective tissue before chasing heavy weights." },
                { head: "Regression to Progression", body: "Pain is a signal, not a stop sign. It indicates you have exceeded your current load tolerance. We do not avoid the movement; we scale the leverage.\n• Elevation: By elevating the heel or the front foot during split squats, we reduce the demand on ankle mobility and knee flexion.\n• The Path: We start at a height where the movement is pain-free. As structural integrity improves, we lower the elevation inch by inch, progressively earning the right to train flat ground, \"ass-to-grass.\"" },
                { head: "The Verdict", body: "The modern world is designed to shorten your muscles and weaken your joints. \"Knees Over Toes\" is not just a training program; it is a restoration project for the human machine. By reintroducing full range of motion, stimulating synovial fluid, and balancing the kinetic chain, we don't just avoid injury—we build a body that is harder to break." }
            ],
            key_terms: ["Long Range Strength", "VMO Development", "Tibialis Anterior", "Nordic Curl", "Davis’s Law", "Regression to Progression", "Synovial Pump", "Structural Balance"],
            color: "from-amber-500 to-orange-500"
        },
        {
            title: "Diaphragmatic Breathing",
            subtitle: "The Hydraulic Pump of Tensegrity",
            author: "Clinical Analysis",
            desc: "Breathing is the foundation of fascial integrity. Diaphragmatic breathing creates intra-abdominal pressure that supports the spine, enhances sling activation, and facilitates decompression throughout the kinetic chain. Traditional shallow breathing fails to engage the deep core, leading to instability and pain.",
            sections: [
                { head: "Hydraulic Amplification", body: "The diaphragm acts as a piston, creating pressure gradients that distribute force across fascial lines. On inhalation, it descends, pressurizing the abdomen and stabilizing the lumbar spine via the Deep Front Line. This IAP (Intra-Abdominal Pressure) is essential for tensegrity, allowing the body to elongate under load without compression." },
                { head: "Integration with Movement", body: "Sync breath with motion: Inhale during elongation (e.g., arm raise) to create space; exhale on exertion (e.g., twist) to brace. This integrates slings—e.g., diaphragmatic breath enhances POS during gait by linking core to glutes. Poor breathing disconnects chains, causing compensatory tension." },
                { head: "Common Dysfunctions", body: "Sedentary life promotes chest breathing, weakening the diaphragm and overloading neck/shoulders (leading to tech neck). Training breath restores pump mechanism, circulating synovial fluid and reducing joint wear." }
            ],
            key_terms: ["Diaphragm", "Intra-Abdominal Pressure", "Breath Synchronization", "Hydraulic Tensegrity"],
            color: "from-cyan-600 to-blue-500"
        },
        {
            title: "Marv Marinovich",
            subtitle: "The Godfather of Neuro-Mechanical Genius",
            author: "by Marv Marinovich",
            desc: "He didn’t just train athletes. He rewired the entire human nervous system from the ground up, treating the body as a living antenna for cosmic force. Long before “functional training” became a marketing slogan, Marv was running a 50-year human experiment on how to turn a child (and later hundreds of elite athletes) into a biological super-conductor.",
            sections: [
                { head: "The Nervous System Is the Athlete", body: "Muscles are dumb meat. The nervous system is the pilot. Marv’s entire philosophy: if you can increase the speed, precision, and volume of neural impulses traveling through the body, the muscles will automatically become stronger, faster, and more resilient. He called it “neuro-mechanical efficiency.” Quentin Torres calls it “turning the body into a Tesla coil.”" },
                { head: "Movement Is Medicine, But Only If It’s Wave-Based", body: "Marv was obsessed with spinal waves and segmental articulation decades before anyone talked about “fascial slings.” Watch any old clip of Todd Marinovich at age 4: he’s doing perfect spinal waves on a Swiss ball while balancing on one leg. Marv understood that the spine is a helical antenna. Every vertebra must be able to move independently so the body can absorb, store, and redirect force like a whip. Quentin: “Marv taught me the body is a standing wave. If one segment is stuck, the whole wave collapses.”" },
                { head: "Elasticity Over Rigidity", body: "Marv hated stiff, braced cores. He wanted the torso to coil and uncoil like a python. His infamous “Marinovich rolls,” “spinal rocks,” and “ball waves” were designed to create segmental mobility from sacrum to occiput. The goal: turn the torso into a living spring that stores elastic energy instead of leaking it through a locked lumbar spine." },
                { head: "The Foot Is the Root of All Power", body: "Marv was barefoot/minimalist before it was cool. He had Todd training on sand, grass, and unstable surfaces from infancy. He knew the foot is the first point of contact with the Earth’s electromagnetic field. Strong intrinsic foot muscles + hyper-mobile midfoot = instant neural drive up the posterior chain. Quentin: “Marv used to say, ‘If the foot can’t feel the ground, the glutes can’t feel the lats.’”" },
                { head: "Contralateral Reciprocation Is the Engine of Humanity", body: "Marv was obsessed with opposite arm/opposite leg gait patterns. He trained crawling, bear crawls, and reciprocal reaching from birth because he understood the X-pattern across the torso (what we now call the Posterior & Anterior Oblique Slings) is the biological source of rotational power. Lock the ribs to the pelvis and you kill the engine." },
                { head: "The Breath Is the Master Controller", body: "Marv used crocodile breathing, 90/90 breathing, and ballistic exhales to teach athletes how to create intra-abdominal pressure without bracing into extension. He knew the diaphragm is the hydraulic pump that links the upper and lower body through the deep front line. Quentin still teaches “Marv’s breath”: exhale on the coil, inhale on the elongation." },
                { head: "Train the Unconscious First", body: "Most coaches train the conscious mind. Marv trained the autonomic nervous system. He used Swiss balls, wobble boards, blindfolds, reactive drills, and bilateral asymmetry from day one so the nervous system would learn to solve problems faster than thought. The result: athletes who moved like liquid lightning without overthinking." },
                { head: "The 0–5 Window Is Sacred", body: "Marv’s most controversial (and most esoteric) belief: 0–5 years old is when the nervous system is most plastic and most receptive to “downloading” perfect movement templates. He treated Todd like a human super-computer being programmed with flawless code before the ego and cultural distortion set in. Love it or hate it, the results were undeniable." },
                { head: "The Verdict", body: "Marv Marinovich didn’t just raise the first million-dollar quarterback. He proved that the human body is a neuro-mechanical antenna capable of receiving, amplifying, and transmitting force at levels most people believe are genetically impossible. He wasn’t training muscles. He was training the living wave that travels through the fascia, the breath, and the spiral of the spine. Modern “functional training” is still catching up to what Marv was doing in a garage in 1975." }
            ],
            key_terms: ["Neuro-Mechanical Efficiency", "Spinal Wave", "Segmental Articulation", "Contralateral Reciprocation", "Elastic Torso", "Marinovich Breath", "0-5 Plasticity", "Living Antenna"],
            color: "from-purple-600 to-pink-600"
        }
    ];

    // --- PRESET PROTOCOLS ---
   const PRESET_PROTOCOLS = {
    "Tech Neck": ["head_loading", "chest_opener", "trap_release", "standing_pull"],
    "Rounded Shoulders": ["chest_opener", "arm_raise", "standing_pull", "body_wave"],
    "Sedentary Reset": ["body_bounce", "split_squat", "trunk_twist", "plantar_release"],
    "Hyperarch Fascia Protocol": ["plantar_release", "towel_curl", "hyperarch"],
    "Head-Loaded Power Flow": ["head_loading", "head_loaded_standing_hinge", "head_loaded_split_squat", "head_loaded_coiling"]
};

    // --- HYPER-PERSONALIZED DATABASE (V85.0 APEX ARCHITECT) ---
    const EXERCISE_DB = [
        // PHASE 1: STRUCTURAL REPAIR
        { id: "head_loading", title: "Cervical Alignment", target_grade: "head", pattern: "posture_reset", tissues: "Deep Spine / Multifidus", phase: 1, synergies: ["Neck Pain", "Back Pain"], equipment: "none", levels: [
    { level: 1, name: "Head Retraction", demoType: "head_loading_basic", duration: 60, desc: "Simple chin tucks against a wall to reset posture.", steps: ["Stand against wall", "Tuck chin", "Hold 5s"], videoSearch: "standing chin tuck exercise against wall" },
    { level: 2, name: "Head-Loaded Standing Hip Hinge", demoType: "head_hinge", duration: 90, desc: "Basic axial loading with hip hinge to teach posterior chain under head load.", steps: ["Balance 5-10lb on head", "Hands on hips", "Hinge at hips, push butt back", "Keep spine neutral", "Return to stand"], videoSearch: "good morning exercise with medicine ball overhead" },
    { level: 3, name: "Weighted Head Loading (Standing)", demoType: "head_loading_basic", duration: 90, desc: "Axial decompression standing tall.", steps: ["Balance light weight on head", "Reach arms up", "Breathe deep"], videoSearch: "medicine ball balanced on head posture" },
    { level: 4, name: "Head Loaded March", demoType: "head_march", duration: 60, desc: "Dynamic stability marching.", steps: ["Load head", "March slowly", "No wobble"], videoSearch: "posture head weighting marching" }
] },
        { id: "plantar_release", title: "Plantar Release", target_grade: "gait", pattern: "foot_release", tissues: "Plantar Fascia", phase: 1, synergies: ["Foot Pain", "Knee Pain", "Back Pain"], equipment: "required", levels: [ { level: 1, name: "Standing Foot Roll", demoType: "foot_roll", duration: 90, desc: "Break up fascial adhesions while loaded.", steps: ["Stand on ball", "Apply bodyweight", "Find hot spots"], videoSearch: "standing plantar fascia release golf ball" }, { level: 2, name: "Plantar Fascia Release", demoType: "foot_roll", duration: 90, desc: "Shift weight dynamically across the arch.", steps: ["Ball under arch", "Shift weight front/back", "Breathe"], videoSearch: "standing plantar fascia release technique" }, { level: 3, name: "Active Toe Splay", demoType: "foot_roll", duration: 60, desc: "Neurological reactivation.", steps: ["Stand tall", "Splay toes", "Drive big toe down", "Lift others"], videoSearch: "toe splay foot exercise" } ] },
        { id: "split_squat", title: "Knee Restoration", target_grade: "hip", pattern: "knee_flexion", tissues: "VMO / Hip Flexor", phase: 1, synergies: ["Knee Pain", "Back Pain", "Foot Pain"], equipment: "none", levels: [ { level: 1, name: "Assisted Split Squat", demoType: "split_squat", duration: 60, desc: "Use support to unload bodyweight.", steps: ["Hold support", "Front foot flat", "Knee over toe"], videoSearch: "atg split squat assisted form" }, { level: 2, name: "ATG Split Squat", demoType: "split_squat", duration: 60, desc: "Full range bodyweight split squat.", steps: ["Long stride", "Back leg straight", "Cover hamstring with calf"], videoSearch: "atg split squat knees over toes" }, { level: 3, name: "Headloaded Split Squat", demoType: "split_squat", duration: 60, desc: "Advanced: Axial load forces perfect spinal alignment.", steps: ["Balance up to 10lb on head", "Perform split squat and exaggerate your knees over toes", "Absolute control"], videoSearch: "ATG loaded split squat" },     { level: 4, name: "Head-Loaded ATG Split Squat", demoType: "head_split", duration: 90, desc: "Head load forces perfect alignment in deep split squat.", steps: ["Balance 5-10lb on head", "Long stride", "Deep drop, knee over toe", "Slow reps"], videoSearch: "overhead medicine ball lunge deep" } ] },
        { id: "trap_release", title: "Shoulder Release", target_grade: "shoulders", pattern: "tissue_release", tissues: "Upper Traps", phase: 1, synergies: ["Neck Pain", "Headache"], equipment: "required", levels: [ { level: 1, name: "Upper Trap Smash", demoType: "shoulder_release", duration: 90, desc: "Basic release.", steps: ["Ball on wall", "Lean in", "Breathe"], videoSearch: "upper trap release lacrosse ball wall" }, { level: 2, name: "Active Trap Pin", demoType: "shoulder_release", duration: 90, desc: "Release with arm movement.", steps: ["Pin tissue", "Raise arm", "Lower arm"], videoSearch: "upper trap active release technique" } ] },
        { id: "standing_pull", title: "Scapular Stability", target_grade: "shoulders", pattern: "upper_pull", priority: "secondary", tissues: "Lower Traps / Rhomboids", phase: 1, synergies: ["Neck Pain", "Posture"], equipment: "required", levels: [ { level: 1, name: "Band Pull Aparts", demoType: "standing_pull", duration: 60, desc: "Scapular retraction.", steps: ["Hold band", "Pull apart", "Squeeze blades"], videoSearch: "resistance band pull aparts form" }, { level: 2, name: "Cable Face Pulls", demoType: "standing_pull", duration: 60, desc: "External rotation and retraction.", steps: ["Pull to face", "Rotate hands up", "Squeeze"], videoSearch: "cable face pull proper form" } ] },
        { id: "diaphragm_breath", title: "Diaphragmatic Integration", target_grade: "spine", pattern: "breath_flow", tissues: "Deep Front Line / Diaphragm", phase: 1, synergies: ["Back Pain", "Neck Pain", "Stiffness"], equipment: "none", levels: [ { level: 1, name: "Supine Breath Hold", demoType: "diaphragm_breath", duration: 60, desc: "Basic diaphragm activation.", steps: ["Lie flat", "Hand on belly", "Inhale deep, hold 5s"], videoSearch: "supine diaphragmatic breathing" }, { level: 2, name: "Crocodile Breath", demoType: "diaphragm_breath", duration: 90, desc: "Prone for back line integration.", steps: ["Face down", "Forehead on hands", "Belly breathe against floor"], videoSearch: "crocodile breathing exercise" }, { level: 3, name: "Integrated Breath Flow", demoType: "diaphragm_breath", duration: 120, desc: "Pair with movement.", steps: ["Inhale during elongation", "Exhale on coil", "Sync with wave"], videoSearch: "integrated diaphragmatic breathing in movement" } ] },

        // PHASE 2: FASCIAL ELASTICITY
        { id: "body_bounce", title: "Fascial Bounce", target_grade: "hip", pattern: "rhythmic_loading", tissues: "Lateral Line / Glute Med", phase: 2, synergies: ["Hip Impingement", "Stiffness"], equipment: "none", levels: [ { level: 1, name: "Body Bounce w/ Hip Shift", demoType: "body_bounce", duration: 60, desc: "Rhythmic bouncing with lateral hip shifts to engage fascia.", steps: ["Bounce on balls of feet", "Shift hips left and right", "Keep rhythm"], videoSearch: "standing lymphatic bounce exercise with hip shift" } ] },
        { id: "hyperarch", title: "Fascial Elasticity", target_grade: "gait", pattern: "elasticity", tissues: "Achilles / Fascia", phase: 2, synergies: ["Foot Pain", "Knee Pain"], equipment: "none", levels: [ { level: 1, name: "Pogo Hops", demoType: "hyperarch_hop", duration: 30, desc: "Build stiffness.", steps: ["Small bounces", "Legs straight", "Balls of feet"], videoSearch: "pogo hops plyometrics" }, { level: 2, name: "Hyperarch Hops", demoType: "hyperarch_hop", duration: 45, desc: "Maximal fascial loading.", steps: ["Suspend heel", "Rapid recoil", "Glute driven"], videoSearch: "hyperarch fascia training glute hops" } ] },
        { id: "towel_curl", title: "HFT Towel Curls", target_grade: "gait", pattern: "foot_release", tissues: "Plantar Fascia / Intrinsic Foot", phase: 2, synergies: ["Foot Pain", "Knee Pain", "Back Pain"], equipment: "required", levels: [ { level: 1, name: "Seated Towel Curl", demoType: "towel_curl", duration: 60, desc: "Basic toe scrunch seated.", steps: ["Sit", "Towel under foot", "Scrunch toes"], videoSearch: "seated towel curl exercise" }, { level: 2, name: "Standing Towel Curl", demoType: "towel_curl", duration: 90, desc: "Add weight bearing.", steps: ["Stand", "Scrunch with full weight"], videoSearch: "standing towel curl" }, { level: 3, name: "Dynamic Towel Pull", demoType: "towel_curl", duration: 60, desc: "Pull towel towards you.", steps: ["Pull towel with toes", "Repeat"], videoSearch: "dynamic towel scrunch" } ] },
        { id: "chest_opener", title: "Chest Opener", target_grade: "shoulders", pattern: "anterior_stretch", tissues: "Pectorals / Biceps", phase: 2, synergies: ["Posture", "Neck Pain"], equipment: "none", levels: [ { level: 1, name: "Dynamic Chest Opener", demoType: "chest_opener", duration: 60, desc: "Opening the front line of the body.", steps: ["Cross arms in front", "Open wide & squeeze", "Use momentum"], videoSearch: "standing lymphatic bounce exercise with hip shift" } ] },
        { id: "alt_arm_raise", title: "Reciprocal Arms", target_grade: "shoulders", pattern: "coordination", tissues: "Latissimus Dorsi", phase: 2, synergies: ["Gait Efficiency", "Shoulder Pain"], equipment: "none", levels: [ { level: 1, name: "Alternate Arm Raise", demoType: "alt_arm_raise", duration: 60, desc: "Disassociating shoulder movements.", steps: ["One arm up", "One arm down", "Switch rhythmically"], videoSearch: "standing lymphatic bounce exercise with hip shift" } ] },

        // PHASE 3: ROTATIONAL POWER
        { id: "pallof", title: "Core Stability", target_grade: "spine", pattern: "anti_rotation", tissues: "Oblique Sling", phase: 3, synergies: ["Back Pain", "Knee Pain"], equipment: "required", levels: [ { level: 1, name: "Pallof Hold", demoType: "pallof_press", duration: 45, desc: "Static anti-rotation hold.", steps: ["Hold band", "Arms extended", "Resist twist"], videoSearch: "pallof press hold form" }, { level: 2, name: "Pallof Press", demoType: "pallof_press", duration: 60, desc: "Dynamic press resisting rotation.", steps: ["Press out", "Return slow", "Hips square"], videoSearch: "standing pallof press tutorial" }, { level: 3, name: "Chopping Pallof", demoType: "pallof_press", duration: 60, desc: "Dynamic chopping motion.", steps: ["Rotational chop", "Explosive return", "Core brace"], videoSearch: "cable woodchopper exercise" } ] },
        { id: "landmine_rotation", title: "Rotational Strength", target_grade: "spine", pattern: "anti_rotation", tissues: "Anterior Oblique Sling", phase: 3, synergies: ["Back Pain", "Gait Efficiency"], equipment: "required", levels: [ { level: 1, name: "Landmine Anti-Rotation", demoType: "landmine_rotation", duration: 45, desc: "Resisting torque.", steps: ["Bar in front", "Move arc side to side", "Hips still"], videoSearch: "landmine anti rotation rainbow" }, { level: 2, name: "Landmine Twist", demoType: "landmine_twist", duration: 60, desc: "Integrated hip and spine rotation.", steps: ["Pivot feet", "Rotate hips", "Press bar across body"], videoSearch: "full contact twist landmine" } ] },
        { id: "band_twist", title: "Band Twist", target_grade: "spine", pattern: "power_rotation", tissues: "Obliques / Transverse Plane", phase: 3, synergies: ["Back Pain", "Hip Hike"], equipment: "required", levels: [ { level: 1, name: "Standing Band Twist", demoType: "band_twist", duration: 60, desc: "Controlled rotational torque.", steps: ["Hold band", "Pivot feet", "Rotate 180 degrees"], videoSearch: "standing resistance band trunk twist" }, { level: 2, name: "Explosive Band Twist", demoType: "band_twist", duration: 60, desc: "Power development.", steps: ["Load back", "Snap hips", "Rotate hard"], videoSearch: "explosive band rotation exercise" } ] },
        { id: "coiling", title: "Rotational Power", target_grade: "spine", pattern: "core_flow", tissues: "Spiral Line", phase: 3, synergies: ["Back Pain", "Gait Efficiency"], equipment: "none", levels: [ { level: 1, name: "Static Coiling Hold", demoType: "coiling_lunge", duration: 45, desc: "Learn the position.", steps: ["Lunge", "Side bend", "Align Head Over Foot"], videoSearch: "weckmethod coiling core isometric" }, { level: 2, name: "Pulsing Coiling Lunge", demoType: "weck_pulse", duration: 60, desc: "WeckMethod Rhythmic Pulse.", steps: ["Double down pulse", "Fascial elasticity", "Head over foot"], videoSearch: "weckmethod pulsing lunge tutorial" }, { level: 3, name: "Loaded Coiling", demoType: "coiling_lunge", duration: 60, desc: "Add hand weights.", steps: ["Hold DBs", "Enhance torsion", "Power return"], videoSearch: "weckmethod loaded coiling lunge" },     { level: 4, name: "Head-Loaded Coiling Lunge", demoType: "head_coiling", duration: 90, desc: "Head load amplifies coil and Head-Over-Foot.", steps: ["Balance 5-10lb on head", "Lunge + side bend/rotate", "Pulse the coil"], videoSearch: "weckmethod coiling lunge overhead" } ] },
        { id: "trunk_twist", title: "Trunk Twist", target_grade: "spine", pattern: "rotation", tissues: "Spiral Line", phase: 3, synergies: ["Back Pain", "Core Stability"], equipment: "none", levels: [ { level: 1, name: "Dynamic Trunk Twist", demoType: "trunk_twist", duration: 60, desc: "Loosening the thoracic spine with rhythmic rotation.", steps: ["Feet wide", "Rotate torso", "Let arms swing loosely"], videoSearch: "standing lymphatic bounce exercise with hip shift" } ] },

        // PHASE 4: INTEGRATED FLOW
        { id: "spinal_wave", title: "Integrated Spine", target_grade: "spine", pattern: "core_flow", tissues: "Full Body Fascia", phase: 4, requires_mastery: ["body_wave", "coiling"], synergies: ["Back Pain", "Neck Pain"], equipment: "none", levels: [ { level: 1, name: "Standing Spinal Roll", demoType: "spinal_wave", duration: 60, desc: "Segmental flexion/extension.", steps: ["Chin to chest", "Roll down spine", "Roll up"], videoSearch: "standing spinal roll down pilates" }, { level: 2, name: "Marinovich Spinal Wave", demoType: "spinal_wave", duration: 60, desc: "Segmental activation of the spine.", steps: ["Sit or lie over the ball so your back is supported.", "Initiate a wave from the tailbone through the spine up to the head.", "Arms can move overhead, side-to-side, or reach forward to integrate upper body."], videoSearch: "https://www.youtube.com/watch?v=H9Ai26Au5Kc&list=PLkJzahJiwLT4Qu2fl_877pWJtCJo39HI-" } ] },
        { id: "body_wave", title: "Body Wave", target_grade: "spine", pattern: "spinal_flow", tissues: "Superficial Back Line", phase: 4, synergies: ["Back Pain", "Stiffness"], equipment: "none", levels: [ { level: 1, name: "Standing Body Wave", demoType: "body_wave", duration: 60, desc: "Rhythmic arm swings driving body extension.", steps: ["Swing arms back & bend knees", "Swing arms overhead & extend", "Keep rhythm"], videoSearch: "standing lymphatic bounce exercise with hip shift" } ] },
        { id: "med_ball_power", title: "Explosive Power", target_grade: "spine", pattern: "power_rotation", tissues: "Full Body Fascia", phase: 4, synergies: ["Athletic Performance", "Stiffness"], equipment: "required", levels: [ { level: 1, name: "Standing Overhead Slam", demoType: "med_ball_slam", duration: 30, desc: "Full body flexion power.", steps: ["Stand tall", "Lift ball", "Slam hard"], videoSearch: "medicine ball overhead slam form" } ] },
        { id: "contra_pull", title: "Contralateral Pull", target_grade: "shoulders", pattern: "reciprocal_pull", tissues: "Posterior Oblique Sling", phase: 4, synergies: ["Back Pain", "Gait Efficiency", "Shoulder Impingement"], equipment: "required", levels: [ { level: 1, name: "Static Contra Hold", demoType: "contra_pull", duration: 45, desc: "Isometric sling fire.", steps: ["Band in right hand", "Left foot steps back", "Pull & resist"], videoSearch: "contralateral band pull hold" }, { level: 2, name: "Dynamic Contra Pull", demoType: "contra_pull", duration: 60, desc: "Add movement.", steps: ["Pull band while stepping", "Alternate sides", "Keep tension"], videoSearch: "contralateral resistance band pull" }, { level: 3, name: "Explosive Contra Snap", demoType: "contra_pull", duration: 45, desc: "Power version.", steps: ["Quick pull & release", "Hip drive", "Full recoil"], videoSearch: "explosive contralateral band snap" } ] },
        { id: "inversion_hang", title: "Inversion Decompression", target_grade: "hip", pattern: "inversion_flow", tissues: "Superficial Back Line", phase: 4, synergies: ["Back Pain", "Hip Impingement", "Stiffness"], equipment: "none", levels: [ { level: 1, name: "Supported Inversion Hold", demoType: "inversion_hang", duration: 30, desc: "Gentle hang.", steps: ["Hang from bar/wall", "Relax shoulders", "Breathe deep"], videoSearch: "supported inversion hang" }, { level: 2, name: "Active Inversion Twist", demoType: "inversion_hang", duration: 45, desc: "Add rotation.", steps: ["Hang & twist hips", "Alternate sides", "Control descent"], videoSearch: "inversion hang with twist" }, { level: 3, name: "Dynamic Inversion Flow", demoType: "inversion_hang", duration: 60, desc: "Full integration.", steps: ["Hang to pull-up", "Add leg swings", "Fascia release"], videoSearch: "dynamic inversion flow exercise" } ] },
        { id: "arm_raise", title: "Arm Raises", target_grade: "shoulders", pattern: "shoulder_mobility", tissues: "Deep Front Arm Line", phase: 4, synergies: ["Neck Pain", "Shoulder Impingement"], equipment: "none", levels: [ { level: 1, name: "Thumbs Up Arm Raise", demoType: "arm_raise", duration: 60, desc: "Overhead range of motion with external rotation cue.", steps: ["Thumbs up", "Raise arms straight front", "Keep ribs down"], videoSearch: "standing lymphatic bounce exercise with hip shift" } ] }
    ];

    // --- NEW: GOAL PRESETS (For Retention) ---
    const GOAL_PRESETS = [
        { id: "beginner", title: "Starter Build", target: 70, desc: "Build foundational posture in 30 days.", exercises: 4 },
        { id: "athlete", title: "Elite Power", target: 90, desc: "Unlock rotational power in 60 days.", exercises: 6 },
        { id: "recovery", title: "Pain Free", target: 85, desc: "Eliminate chronic pain in 45 days.", exercises: 5 }
    ];

    // --- COMPONENTS ---

    const BioAvatar = ({ audit, symptoms = [], onPartClick }) => {
        // Colors based on grade
        const getColor = (grade) => {
            switch(grade) {
                case 'A': return "fill-emerald-500/20 stroke-emerald-500 hover:fill-emerald-500/40";
                case 'B': return "fill-blue-500/20 stroke-blue-500 hover:fill-blue-500/40";
                case 'C': return "fill-yellow-500/20 stroke-yellow-500 hover:fill-yellow-500/40";
                case 'D': return "fill-orange-500/20 stroke-orange-500 hover:fill-orange-500/40";
                case 'F': return "fill-red-500/20 stroke-red-500 hover:fill-red-500/40 animate-pulse";
                default: return "fill-slate-700 stroke-slate-600";
            }
        };
        
        // PRIORITY LOGIC: Pain trumps Grade. 
        // If a symptom is active for a region, it glows red/alert regardless of the scan score.
        const getFill = (part, gradeObj) => {
            if (part === 'head' && symptoms.includes('Neck Pain')) return "fill-red-500/30 stroke-red-500 animate-pulse";
            if (part === 'spine' && symptoms.includes('Back Pain')) return "fill-red-500/30 stroke-red-500 animate-pulse";
            if (part === 'hip' && (symptoms.includes('Back Pain') || symptoms.includes('Knee Pain'))) return "fill-orange-500/30 stroke-orange-500 animate-pulse"; // Hips link to both
            if (part === 'gait' && (symptoms.includes('Knee Pain') || symptoms.includes('Foot Pain'))) return "fill-red-500/30 stroke-red-500 animate-pulse";
            
            // Fallback to Scan Grade
            return audit ? getColor(gradeObj.grade) : "fill-slate-800 stroke-slate-700";
        };

        const headC = getFill('head', audit ? audit.head : {});
        const shC = audit ? getColor(audit.shoulders.grade) : "fill-slate-800 stroke-slate-700"; // Shoulders usually secondary
        const spineC = getFill('spine', audit ? audit.spine : {});
        const hipC = getFill('hip', audit ? audit.hip : {});
        const legC = getFill('gait', audit ? audit.gait : {});

        return (
            <svg viewBox="0 0 200 400" className="w-full h-[360px] drop-shadow-2xl living-avatar">
                <g onClick={()=>onPartClick && onPartClick('gait')} className={`body-part ${legC}`}>
                    <path strokeWidth="2" d="M70,220 Q60,300 65,380 L85,380 Q90,300 95,220 Z" /> {/* L Leg */}
                    <path strokeWidth="2" d="M130,220 Q140,300 135,380 L115,380 Q110,300 105,220 Z" /> {/* R Leg */}
                </g>
                <g onClick={()=>onPartClick && onPartClick('hip')} className={`body-part ${hipC}`}>
                    <path strokeWidth="2" d="M60,180 Q50,200 60,220 L140,220 Q150,200 140,180 Z" /> {/* Hips */}
                </g>
                <g onClick={()=>onPartClick && onPartClick('spine')} className={`body-part ${spineC}`}>
                    <path strokeWidth="2" d="M65,100 L135,100 L140,180 L60,180 Z" /> {/* Torso */}
                </g>
                <g onClick={()=>onPartClick && onPartClick('shoulders')} className={`body-part ${shC}`}>
                    <path strokeWidth="2" d="M40,100 Q30,150 25,200 L45,200 Q50,150 65,110 Z" /> {/* L Arm */}
                    <path strokeWidth="2" d="M160,100 Q170,150 175,200 L155,200 Q150,150 135,110 Z" /> {/* R Arm */}
                    <ellipse cx="100" cy="100" rx="40" ry="10" /> {/* Shoulders */}
                </g>
                <g onClick={()=>onPartClick && onPartClick('head')} className={`body-part ${headC}`}>
                    <circle cx="100" cy="60" r="25" strokeWidth="2" /> {/* Head */}
                </g>
                
                {/* Grid Lines */}
                <line x1="0" y1="380" x2="200" y2="380" stroke="#22d3ee" strokeWidth="1" strokeOpacity="0.3" strokeDasharray="4 4" />
                <line x1="100" y1="0" x2="100" y2="400" stroke="#22d3ee" strokeWidth="1" strokeOpacity="0.2" strokeDasharray="4 4" />
            </svg>
        );
    };

    const AICoach = ({ audit, symptoms, chatHistory, onSend }) => {
        const [input, setInput] = useState("");
        const messagesEndRef = useRef(null);

        useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [chatHistory]);

        const handleSend = (txt) => {
            const msg = txt || input;
            if(!msg.trim()) return;
            onSend(msg);
            setInput("");
        };

        const suggestions = [
            "Explain my Grade",
            "Why headloading?",
            "What is VMO?",
            "Fix Forward Head",
            "Optimize Routine"
        ];

        return (
            <div className="flex flex-col h-full bg-slate-900/50 rounded-lg border border-slate-700 overflow-hidden">
                <div className="p-4 bg-slate-900 border-b border-slate-800 flex justify-between items-center">
                    <div className="flex items-center gap-2">
                        <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                        <span className="text-xs font-bold text-slate-300 uppercase tracking-widest">Bio-AI Coach</span>
                    </div>
                </div>
                <div className="flex-1 overflow-y-auto p-4">
                    {chatHistory.length === 0 ? (
                        <div className="text-center text-slate-500 text-xs mt-10">
                            <p className="mb-2">Analysis Complete.</p>
                            <p>Ask me about your <span className="text-cyan-400">Hip Shift</span> or <span className="text-cyan-400">Protocol</span>.</p>
                        </div>
                    ) : (
                        chatHistory.map((msg, i) => (
                            <div key={i} className={`flex flex-col ${msg.sender === 'user' ? 'items-end' : 'items-start'}`}>
                                <div className={`chat-bubble ${msg.sender === 'user' ? 'chat-user' : 'chat-ai'}`}>
                                    {msg.text}
                                </div>
                                <span className="text-[9px] text-slate-600 mb-2">{msg.sender === 'user' ? 'You' : 'Coach'}</span>
                            </div>
                        ))
                    )}
                    <div ref={messagesEndRef} />
                </div>
                {/* Quick Suggestions */}
                <div className="px-3 pb-2 flex gap-2 overflow-x-auto no-scrollbar">
                    {suggestions.map(s => (
                        <button key={s} onClick={()=>handleSend(s)} className="whitespace-nowrap px-3 py-1 bg-slate-800 border border-slate-700 rounded-full text-[10px] text-cyan-400 hover:bg-slate-700 hover:border-cyan-500/50 transition-all">{s}</button>
                    ))}
                </div>
                <div className="p-3 bg-slate-900 border-t border-slate-800 flex gap-2">
                    <input 
                        value={input}
                        onChange={(e) => setInput(e.target.value)}
                        onKeyDown={(e) => e.key === 'Enter' && handleSend()}
                        placeholder="Ask about your biomechanics..."
                        className="flex-1 bg-slate-950 border border-slate-700 rounded-lg px-3 py-2 text-xs text-white focus:outline-none focus:border-cyan-500"
                    />
                    <button onClick={()=>handleSend()} className="p-2 bg-cyan-600 hover:bg-cyan-500 text-white rounded-lg"><Icons.Send/></button>
                </div>
            </div>
        );
    };

    // --- KINETIC CANVAS ENGINE ---
    const KineticCanvas = ({ type, playing }) => {
        const ref = useRef(null);
        const animationRef = useRef(null);
        
        useEffect(() => {
            if (animationRef.current) cancelAnimationFrame(animationRef.current);
            let startTime = Date.now();
            const loop = () => {
                if (!ref.current) return; 
                const ctx = ref.current.getContext('2d');
                if (!ctx) return;
                const rect = ref.current.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                if (ref.current.width !== Math.floor(rect.width * dpr)) {
                    ref.current.width = rect.width * dpr; ref.current.height = rect.height * dpr; ref.current.height = rect.height * dpr;
                    ctx.scale(dpr, dpr);
                }
                const w = rect.width, h = rect.height, cx = w/2, cy = h/2, s = h/350; 
                
                try {
                    ctx.clearRect(0,0,w,h);
                    ctx.strokeStyle='#1e293b'; ctx.lineWidth=1; ctx.beginPath();
                    for(let i=0; i<w; i+=40) { ctx.moveTo(i, 0); ctx.lineTo(i, h); }
                    for(let i=0; i<h; i+=40) { ctx.moveTo(0, i); ctx.lineTo(w, i); }
                    ctx.stroke();
                    ctx.fillStyle='#0f172a'; ctx.fillRect(0, cy+100*s, w, h-(cy+100*s));
                    ctx.strokeStyle='#22d3ee'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0, cy+100*s); ctx.lineTo(w, cy+100*s); ctx.stroke();

                    const t = (Date.now() - startTime) / 1000;
                    const cycle = Math.sin(t*2.5); const pos = (cycle+1)/2;
                    const safe = (v) => Number.isFinite(v) ? v : 0;
                   
                    const drawSegment = (x1,y1,x2,y2,w,c='#94a3b8') => { ctx.save(); ctx.strokeStyle=c; ctx.lineWidth=w; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(safe(x1),safe(y1)); ctx.lineTo(safe(x2),safe(y2)); ctx.stroke(); ctx.restore(); };
                    const drawMuscle = (x1,y1,x2,y2,w,act,lbl,sd='right') => {
                        const dx=x2-x1, dy=y2-y1, len=Math.sqrt(dx*dx+dy*dy); if(len<1)return;
                        const mx=(x1+x2)/2, my=(y1+y2)/2, nx=-dy/len, ny=dx/len;
                        const bx=mx+nx*w*(act?0.6:0.3)*(sd==='right'?1:-1), by=my+ny*w*(act?0.6:0.3)*(sd==='right'?1:-1);
                        ctx.save(); ctx.strokeStyle=act?'#22d3ee':'#475569'; ctx.lineWidth=2; ctx.fillStyle=act?'rgba(34,211,238,0.3)':'rgba(71,85,105,0.2)';
                        ctx.beginPath(); ctx.moveTo(safe(x1),safe(y1)); ctx.quadraticCurveTo(safe(bx),safe(by),safe(x2),safe(y2)); ctx.fill(); ctx.stroke(); ctx.restore();
                    };
                    const drawEquipment = (tp,x,y,rt) => {
                        ctx.save(); ctx.translate(safe(x),safe(y)); ctx.rotate(rt);
                        if(tp==='ball') { ctx.fillStyle='#f59e0b'; ctx.beginPath(); ctx.arc(0,0,8*s,0,2*Math.PI); ctx.fill(); }
                        else if(tp==='smash_ball') { ctx.fillStyle='#f43f5e'; ctx.beginPath(); ctx.arc(0,0,5*s,0,2*Math.PI); ctx.fill(); }
                        else if(tp==='bar') { ctx.strokeStyle='#64748b'; ctx.lineWidth=6; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(60*s,0); ctx.stroke(); }
                        else if(tp==='swiss') { ctx.fillStyle='#3b82f6'; ctx.beginPath(); ctx.arc(0,0,25*s,0,2*Math.PI); ctx.fill(); }
                        else if(tp==='sled') { ctx.fillStyle='#475569'; ctx.fillRect(-20*s, -10*s, 40*s, 20*s); }
                        else if(tp==='dumbbell') { ctx.fillStyle='#334155'; ctx.fillRect(-10*s, -5*s, 20*s, 10*s); ctx.fillRect(-15*s, -8*s, 5*s, 16*s); ctx.fillRect(10*s, -8*s, 5*s, 16*s); }
                        else if(tp==='plate') { ctx.fillStyle='#1e293b'; ctx.beginPath(); ctx.ellipse(0,0, 15*s, 15*s, 0, 0, 2*Math.PI); ctx.fill(); ctx.strokeStyle='#94a3b8'; ctx.lineWidth=2; ctx.stroke(); }
                         else if(tp==='handle') { ctx.fillStyle='#334155'; ctx.fillRect(-5*s, -15*s, 10*s, 30*s); }
                         else if(tp==='towel') { ctx.fillStyle='#e2e8f0'; ctx.fillRect(-30*s, 0, 60*s, 3*s); ctx.strokeStyle='#cbd5e1'; ctx.lineWidth=1; ctx.strokeRect(-30*s, 0, 60*s, 3*s); }
                         else if(tp==='pullup_bar') { ctx.strokeStyle='#64748b'; ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(-50*s, 0); ctx.lineTo(50*s, 0); ctx.stroke(); ctx.fillStyle='#475569'; ctx.fillRect(-5*s, -5*s, 10*s, 10*s); } // Grip
                        ctx.restore();
                    };

                    const drawForce = (x, y, dirX, dirY, lbl) => {
                        const scale = 40*s;
                        ctx.save(); ctx.strokeStyle='#f59e0b'; ctx.lineWidth=3; ctx.setLineDash([2,2]);
                        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + dirX*scale, y + dirY*scale); ctx.stroke();
                        ctx.translate(x + dirX*scale, y + dirY*scale); ctx.rotate(Math.atan2(dirY, dirX));
                        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-5*s, -5*s); ctx.lineTo(-5*s, 5*s); ctx.fill();
                        ctx.restore();
                        ctx.fillStyle='#f59e0b'; ctx.font='bold 9px monospace'; ctx.fillText(lbl, x + dirX*scale + 5, y + dirY*scale);
                    };

                    // Easing function for smoother animations
                    const easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;

                    // --- SCENES ---
                    if (type === 'split_squat') {
                        const phase = easeInOutCubic((Math.sin(t * 2) + 1) / 2); // Smoother motion with easing
                        const lunge = phase * 20 * s;
                        const footY = cy + 80 * s;
                        const kneeY = cy + 20 * s + lunge;
                        const hipY = cy - 20 * s + lunge;
                        const backFootX = cx - 60 * s;
                        const backKneeY = cy + 40 * s + lunge / 2;
                        const backKneeX = backFootX + 20 * s;
                        drawSegment(cx, hipY, backKneeX, backKneeY, 16 * s, '#475569'); // Thigh
                        drawSegment(backKneeX, backKneeY, backFootX, footY, 10 * s, '#475569'); // Shin
                        const frontFootX = cx + 40 * s;
                        const frontKneeX = frontFootX + 20 * s; // Knee over toe
                        const frontThighX = cx + (frontKneeX - cx) * 0.3; // Add mid-thigh point for curve
                        const frontThighY = hipY + (kneeY - hipY) * 0.3;
                        ctx.beginPath(); ctx.moveTo(cx, hipY); ctx.quadraticCurveTo(frontThighX, frontThighY, frontKneeX, kneeY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 14 * s; ctx.stroke(); // Curved thigh for realism
                        drawSegment(frontKneeX, kneeY, frontFootX, footY, 16 * s, '#22d3ee'); // Shin
                        drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569'); 
                        ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        drawMuscle(cx + 10 * s, hipY + 10 * s, frontKneeX, kneeY - 5 * s, 14 * s, true, "VMO", 'right');
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ATG SPLIT SQUAT", 20, 30);
                        drawForce(frontKneeX, kneeY, 0.5, 0.5, "KNEE OVER TOE");
                        // Actionable cue: Highlight VMO activation phase
                        if (phase > 0.5) {
                            ctx.save(); ctx.globalAlpha = 0.5 + Math.sin(t * 5) * 0.3; // Pulsing highlight
                            ctx.fillStyle = '#22d3ee'; ctx.fillRect(frontKneeX - 10 * s, kneeY - 20 * s, 20 * s, 20 * s);
                            ctx.restore();
                        }
                    }
                    else if (type === 'body_bounce') {
                        // REFINED: Based on video - bouncing w/ significant hip rotation
                        const bouncePhase = easeInOutCubic(Math.abs(Math.sin(t * 6)) / 2 + 0.5); // Smoother fast bounce
                        const bounce = bouncePhase * 8 * s;
                        const shiftPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                        const shift = shiftPhase * 15 * s;
                        const twistPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                        const twist = twistPhase * 0.4;
                        
                        const hipX = cx + shift;
                        const hipY = cy + 20 * s - bounce;
                        const footY = cy + 100 * s;
                        const headY = hipY - 70 * s;
                        
                        // Legs slanted due to shift with knee bend for realism
                        const leftKneeY = hipY + (footY - hipY) * 0.5 + Math.sin(t * 6) * 2 * s; // Slight knee flex
                        const leftKneeX = cx - 15 * s + (hipX - (cx - 5 * s)) * 0.5;
                        ctx.beginPath(); ctx.moveTo(cx - 15 * s, footY); ctx.quadraticCurveTo(leftKneeX, leftKneeY, hipX - 5 * s, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                        const rightKneeY = hipY + (footY - hipY) * 0.5 - Math.sin(t * 6) * 2 * s; // Opposite flex
                        const rightKneeX = cx + 15 * s + (hipX - (cx + 5 * s)) * 0.5;
                        ctx.beginPath(); ctx.moveTo(cx + 15 * s, footY); ctx.quadraticCurveTo(rightKneeX, rightKneeY, hipX + 5 * s, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                        
                        // Torso with slight rotation cue and curve for spine
                        ctx.save();
                        ctx.translate(hipX, hipY);
                        ctx.rotate(twist); // Twist the hips
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(5 * s * Math.sin(t * 2), -35 * s, 0, -70 * s); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke(); // Curved torso
                        ctx.restore();
                        
                        // Head with slight tilt
                        ctx.beginPath(); ctx.arc(hipX + twist * 5 * s, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        
                        // Arms relaxed, loose with elbow bend
                        const armBounce = easeInOutCubic((Math.sin(t * 6 + Math.PI) + 1) / 2) * 5 * s;
                        const leftElbowX = hipX - 20 * s - 10 * s * Math.sin(t * 2); const leftElbowY = headY + 10 * s + armBounce / 2;
                        ctx.beginPath(); ctx.moveTo(hipX - 20 * s, headY + 10 * s); ctx.quadraticCurveTo(leftElbowX, leftElbowY, hipX - 35 * s, headY + 40 * s + armBounce); ctx.strokeStyle = '#475569'; ctx.lineWidth = 6 * s; ctx.stroke();
                        const rightElbowX = hipX + 20 * s + 10 * s * Math.sin(t * 2); const rightElbowY = headY + 10 * s - armBounce / 2;
                        ctx.beginPath(); ctx.moveTo(hipX + 20 * s, headY + 10 * s); ctx.quadraticCurveTo(rightElbowX, rightElbowY, hipX + 35 * s, headY + 40 * s + armBounce); ctx.strokeStyle = '#475569'; ctx.lineWidth = 6 * s; ctx.stroke();
                        
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("FASCIAL BOUNCE W/ HIP TWIST", 20, 30);
                        drawForce(hipX, hipY, shift > 0 ? 1 : -1, 0, "SHIFT & TWIST");
                        // Actionable cue: Pulsing shift arrow
                        if (shiftPhase > 0.7) {
                            ctx.save(); ctx.globalAlpha = 0.6 + Math.sin(t * 10) * 0.4;
                            drawForce(hipX, hipY, shift > 0 ? 1 : -1, 0, "SHIFT");
                            ctx.restore();
                        }
                    }
                    else if (type === 'body_wave') {
                        // REFINED: Skier Swing Style - Standing arm swing w/ knee bend
                        // Video shows standing in place, swinging arms down/back (knees bend) then up/overhead (knees straight)
                        const wavePhase = t * 4;
                        const cycle = easeInOutCubic((Math.sin(wavePhase) + 1) / 2); // Smoother cycle
                        
                        // Body posture linked to arm swing
                        // Cycle 0: Arms Back, Knees Bent (Skier Tuck)
                        // Cycle 1: Arms Up, Body Extended
                        
                        const kneeBend = cycle * 15 * s; // Inverted for bend when arms back
                        const trunkLean = cycle * 10 * s; // Lean forward when arms back
                        
                        const hipY = cy + 20 * s + kneeBend;
                        const footY = cy + 100 * s;
                        const headX = cx + trunkLean;
                        const headY = hipY - 70 * s + trunkLean / 2; // Head drops slightly
                        
                        // Legs with knee joints
                        const leftKneeY = hipY + (footY - hipY) * 0.5 - kneeBend / 2; // Bend at knee
                        const leftKneeX = cx - 15 * s + trunkLean / 4;
                        ctx.beginPath(); ctx.moveTo(cx - 15 * s, footY); ctx.quadraticCurveTo(leftKneeX, leftKneeY, cx, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                        const rightKneeY = hipY + (footY - hipY) * 0.5 + kneeBend / 2; // Slight offset
                        const rightKneeX = cx + 15 * s + trunkLean / 4;
                        ctx.beginPath(); ctx.moveTo(cx + 15 * s, footY); ctx.quadraticCurveTo(rightKneeX, rightKneeY, cx, hipY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke();
                        
                        // Torso with curve
                        const midTorsoX = cx + trunkLean / 2; const midTorsoY = hipY - 35 * s;
                        ctx.beginPath(); ctx.moveTo(cx, hipY); ctx.quadraticCurveTo(midTorsoX, midTorsoY, headX, headY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();
                        
                        // Head
                        ctx.beginPath(); ctx.arc(headX, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        
                        // Arms: Swing from Overhead to Behind Hips with elbow bend
                        // Angle -PI (up) to 0.5*PI (back)
                        const armAngle = -Math.PI / 2 - (cycle * Math.PI * 0.7); // Dynamic range
                        
                        const shX = headX;
                        const shY = headY + 10 * s;
                        const armLen = 50 * s;
                        const elbowBend = 10 * s * Math.abs(Math.sin(armAngle)); // Bend elbows naturally
                        
                        const leftElbowX = shX + 0.2 * Math.sin(armAngle) * (armLen / 2) - elbowBend;
                        const leftElbowY = shY + Math.cos(armAngle) * (armLen / 2);
                        const leftHandX = leftElbowX + 0.2 * Math.sin(armAngle + 0.2) * (armLen / 2); // Slight offset for realism
                        const leftHandY = leftElbowY + Math.cos(armAngle + 0.2) * (armLen / 2);
                        drawSegment(shX - 5 * s, shY, leftElbowX, leftElbowY, 10 * s, '#22d3ee');
                        drawSegment(leftElbowX, leftElbowY, leftHandX, leftHandY, 10 * s, '#22d3ee');
                        
                        const rightElbowX = shX + 0.2 * Math.sin(armAngle) * (armLen / 2) + elbowBend;
                        const rightElbowY = shY + Math.cos(armAngle) * (armLen / 2);
                        const rightHandX = rightElbowX + 0.2 * Math.sin(armAngle - 0.2) * (armLen / 2);
                        const rightHandY = rightElbowY + Math.cos(armAngle - 0.2) * (armLen / 2);
                        drawSegment(shX + 5 * s, shY, rightElbowX, rightElbowY, 10 * s, '#22d3ee');
                        drawSegment(rightElbowX, rightElbowY, rightHandX, rightHandY, 10 * s, '#22d3ee');
                        
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("STANDING BODY WAVE (SKIER)", 20, 30);
                        // Actionable cue: Arm swing direction
                        if (cycle > 0.5) {
                            drawForce(shX, shY, 0, -1, "EXTEND ARMS");
                        } else {
                            drawForce(shX, shY, 0, 1, "BEND KNEES");
                        }
                    }
                    else if (type === 'trunk_twist') {
                        // REFINED: Arms are bent at elbows ("washing machine")
                        const rotPhase = easeInOutCubic((Math.sin(t * 4) + 1) / 2); // Smoother rotation
                        const rot = rotPhase * 60; // vigorous twist
                        const hipY = cy + 20 * s;
                        const footY = cy + 100 * s;
                        
                        // Feet wide with slight knee bend
                        const kneeBend = 5 * s + Math.sin(t * 4) * 2 * s;
                        const leftKneeY = hipY + kneeBend; const leftKneeX = cx - 30 * s + (rot * 0.1);
                        ctx.beginPath(); ctx.moveTo(cx - 30 * s, footY); ctx.quadraticCurveTo(leftKneeX, leftKneeY, cx, hipY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();
                        const rightKneeY = hipY - kneeBend; const rightKneeX = cx + 30 * s - rot * 0.1;
                        ctx.beginPath(); ctx.moveTo(cx + 30 * s, footY); ctx.quadraticCurveTo(rightKneeX, rightKneeY, cx, hipY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();
                        
                        // Hips with slight rotation
                        ctx.beginPath(); ctx.arc(cx, hipY, 14 * s, 0, 2 * Math.PI); ctx.fillStyle = '#475569'; ctx.fill();
                        
                        ctx.save();
                        ctx.translate(cx, hipY);
                        ctx.rotate(rot * 0.01); // slight hip rot
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(5 * s * Math.sin(t * 2), -35 * s, 0, -70 * s); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke(); // Curved torso
                        
                        ctx.translate(0, -60 * s);
                        ctx.rotate(rot * Math.PI / 180); // Shoulder rot
                        
                        // Shoulders
                        drawSegment(-20 * s, 0, 20 * s, 0, 16 * s, '#22d3ee');
                        
                        // ARMS: Bent at elbows, hands near chest, swinging with forearm movement
                        // Left Arm
                        const leftUpperAngle = Math.PI / 4 + Math.sin(t * 4) * 0.1;
                        const leftForearmAngle = Math.PI / 2 + Math.cos(t * 4) * 0.1;
                        const leftUpperX = -20 * s + Math.cos(leftUpperAngle) * 20 * s;
                        const leftUpperY = 0 + Math.sin(leftUpperAngle) * 20 * s;
                        drawSegment(-20 * s, 0, leftUpperX, leftUpperY, 8 * s, '#cbd5e1'); // Upper
                        const leftForearmX = leftUpperX + Math.cos(leftForearmAngle) * 15 * s;
                        const leftForearmY = leftUpperY + Math.sin(leftForearmAngle) * 15 * s;
                        drawSegment(leftUpperX, leftUpperY, leftForearmX, leftForearmY, 8 * s, '#cbd5e1'); // Forearm
                        
                        // Right Arm
                        const rightUpperAngle = -Math.PI / 4 - Math.sin(t * 4) * 0.1;
                        const rightForearmAngle = -Math.PI / 2 - Math.cos(t * 4) * 0.1;
                        const rightUpperX = 20 * s + Math.cos(rightUpperAngle) * 20 * s;
                        const rightUpperY = 0 + Math.sin(rightUpperAngle) * 20 * s;
                        drawSegment(20 * s, 0, rightUpperX, rightUpperY, 8 * s, '#cbd5e1'); // Upper
                        const rightForearmX = rightUpperX + Math.cos(rightForearmAngle) * 15 * s;
                        const rightForearmY = rightUpperY + Math.sin(rightForearmAngle) * 15 * s;
                        drawSegment(rightUpperX, rightUpperY, rightForearmX, rightForearmY, 8 * s, '#cbd5e1'); // Forearm
                        
                        // Head with slight counter-rotation
                        ctx.beginPath(); ctx.arc(0 + Math.sin(t * 4) * 2 * s, -15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        
                        ctx.restore();
                        
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("TRUNK TWIST (BENT ARMS)", 20, 30);
                        // Actionable cue: Rotation direction
                        drawForce(cx, hipY - 70 * s, rot > 0 ? 1 : -1, 0, "TWIST TORSO");
                    }
                    else if (type === 'arm_raise') {
                        // REFINED: Arms go straight up and down in front (sagittal), not out to side
                        const hipY = cy + 20 * s;
                        const footY = cy + 100 * s;
                        drawSegment(cx - 10 * s, footY, cx, hipY, 16 * s, '#475569');
                        drawSegment(cx + 10 * s, footY, cx, hipY, 16 * s, '#475569');
                        drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                        ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        
                        const cycle = easeInOutCubic((Math.sin(t * 3) + 1) / 2); // 0 to 1 smoother
                        // Angle: PI (down) to 0 (up)
                        const angle = Math.PI - (cycle * Math.PI); // PI (down) to 0 (up)
                        
                        const shY = hipY - 60 * s;
                        // Arms originate closer to midline to imply sagittal plane
                        const shL = cx - 5 * s; 
                        const shR = cx + 5 * s;
                        const armLen = 50 * s;
                        
                        // Better: Draw the arc. If sagittal, x changes little, y changes a lot.
                        // Add elbow for realism
                        const elbowBend = 5 * s * (1 - cycle); // More bend when down
                        const lElbowX = shL - 0.2 * Math.sin(angle) * (armLen / 2) - elbowBend;
                        const lElbowY = shY + Math.cos(angle) * (armLen / 2);
                        const lx = lElbowX - 0.2 * Math.sin(angle - 0.1) * (armLen / 2); // Slight curve
                        const ly = lElbowY + Math.cos(angle - 0.1) * (armLen / 2);
                        
                        drawSegment(shL, shY, lElbowX, lElbowY, 8 * s, '#22d3ee');
                        drawSegment(lElbowX, lElbowY, lx, ly, 8 * s, '#22d3ee');
                        
                        const rElbowX = shR + 0.2 * Math.sin(angle) * (armLen / 2) + elbowBend;
                        const rElbowY = shY + Math.cos(angle) * (armLen / 2);
                        const rx = rElbowX + 0.2 * Math.sin(angle + 0.1) * (armLen / 2);
                        const ry = rElbowY + Math.cos(angle + 0.1) * (armLen / 2);
                        
                        drawSegment(shR, shY, rElbowX, rElbowY, 8 * s, '#22d3ee');
                        drawSegment(rElbowX, rElbowY, rx, ry, 8 * s, '#22d3ee');
                        
                        // Thumbs indicator (yellow dot)
                        if (cycle > 0.8) {
                            ctx.beginPath(); ctx.arc(lx, ly - 5 * s, 4 * s, 0, 2 * Math.PI); ctx.fillStyle = '#f59e0b'; ctx.fill();
                            ctx.beginPath(); ctx.arc(rx, ry - 5 * s, 4 * s, 0, 2 * Math.PI); ctx.fillStyle = '#f59e0b'; ctx.fill();
                        }
                        
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SAGITTAL ARM RAISES", 20, 30);
                        // Actionable cue: Thumb up highlight
                        if (cycle > 0.8) {
                            ctx.save(); ctx.globalAlpha = 0.7; ctx.fillStyle = '#f59e0b'; ctx.fillText("THUMBS UP", 20, 50);
                            ctx.restore();
                        }
                    }
                    else if (type === 'chest_opener') {
                        // REFINED: Arms meet in middle (clap/touch) then fling wide
                        const hipY = cy + 20 * s;
                        drawSegment(cx, cy + 100 * s, cx, hipY, 16 * s, '#475569');
                        drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                        ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        
                        const phase = easeInOutCubic((Math.sin(t * 3) + 1) / 2); // Smoother phase
                        const shY = hipY - 60 * s;
                        const maxSpan = 60 * s; 
                        
                        // When phase is 0: Hands meet (span is 0 or small)
                        // When phase is 1: Hands wide (span is max)
                        
                        const currentSpan = phase * maxSpan; // 0 to 60
                        
                        // Add a minimal gap so they "meet"
                        const gap = 5 * s;
                        
                        const lx = cx - gap - currentSpan;
                        const rx = cx + gap + currentSpan;
                        
                        // Arms with slight curve for realism
                        const lCurveX = (cx - 15 * s + lx) / 2; const lCurveY = shY - 5 * s * (1 - phase); // Dip when opening
                        ctx.beginPath(); ctx.moveTo(cx - 15 * s, shY); ctx.quadraticCurveTo(lCurveX, lCurveY, lx, shY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 8 * s; ctx.stroke();
                        const rCurveX = (cx + 15 * s + rx) / 2; const rCurveY = shY + 5 * s * (1 - phase);
                        ctx.beginPath(); ctx.moveTo(cx + 15 * s, shY); ctx.quadraticCurveTo(rCurveX, rCurveY, rx, shY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 8 * s; ctx.stroke();
                        
                        // Visual cue for "meeting"
                        if (currentSpan < 5 * s) {
                             ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(cx, shY, 5 * s, 0, 2 * Math.PI); ctx.fill(); // Spark/Touch
                        }
                        
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("CHEST OPENER (MEET & OPEN)", 20, 30);
                        if (phase > 0.8) drawForce(rx, shY, 1, 0, "EXPAND");
                    }
                    else if (type === 'alt_arm_raise') {
                        // REFINED: Vertical sagittal alternating (Soldier/Swim style)
                        const hipY = cy + 20 * s;
                        const footY = cy + 100 * s;
                        drawSegment(cx - 10 * s, footY, cx, hipY, 16 * s, '#475569');
                        drawSegment(cx + 10 * s, footY, cx, hipY, 16 * s, '#475569');
                        drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                        ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        
                        const shY = hipY - 60 * s;
                        const shL = cx - 15 * s;
                        const shR = cx + 15 * s;
                        const armLen = 50 * s;
                        
                        // Phase for alternation with easing
                        const phase = easeInOutCubic((Math.sin(t * 4) + 1) / 2);
                        
                        // Left Arm: 0 = Down (PI), 1 = Up (0)
                        const lAngle = Math.PI - (phase * Math.PI); // PI to 0
                        
                        // Right Arm: Opposite
                        const rAngle = Math.PI - ((1 - phase) * Math.PI); // 0 to PI (inverted)
                        
                        // Draw with slight sagittal tilt and elbow for depth
                        const lElbowAngle = lAngle + 0.2 * Math.sin(t * 2); // Dynamic bend
                        const lElbowX = shL - Math.sin(lElbowAngle) * (armLen / 2) * s / s;
                        const lElbowY = shY + Math.cos(lElbowAngle) * (armLen / 2);
                        const lx = lElbowX - Math.sin(lAngle) * (armLen / 2) * 5 * s / 100; 
                        const ly = lElbowY + Math.cos(lAngle) * (armLen / 2);
                        
                        drawSegment(shL, shY, lElbowX, lElbowY, 8 * s, '#22d3ee');
                        drawSegment(lElbowX, lElbowY, lx, ly, 8 * s, '#22d3ee');
                        
                        const rElbowAngle = rAngle - 0.2 * Math.sin(t * 2);
                        const rElbowX = shR - Math.sin(rElbowAngle) * (armLen / 2) * s / s;
                        const rElbowY = shY + Math.cos(rElbowAngle) * (armLen / 2);
                        const rx = rElbowX - Math.sin(rAngle) * (armLen / 2) * 5 * s / 100;
                        const ry = rElbowY + Math.cos(rAngle) * (armLen / 2);
                        
                        drawSegment(shR, shY, rElbowX, rElbowY, 8 * s, '#22d3ee');
                        drawSegment(rElbowX, rElbowY, rx, ry, 8 * s, '#22d3ee');
                        
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ALTERNATE ARM RAISES", 20, 30);
                        // Actionable cue: Reciprocal motion label
                        drawForce(cx, shY, 0, phase > 0.5 ? -1 : 1, "ALTERNATE");
                    }
                    else if (type === 'landmine_rotation' || type === 'landmine_twist') {
                        // FIXED: Starts from ground, rigid bar
                        const rotPhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                        const rot = rotPhase * 40 * s;
                        const hipY = cy + 20 * s; const footY = cy + 100 * s;
                        // Legs pivoting with knee bend
                        const pivotLeft = rot > 0;
                        const kneeBend = 5 * s * rotPhase;
                        const leftShinX = cx - 15 * s + (pivotLeft ? kneeBend : 0);
                        drawSegment(cx - 15 * s, hipY, leftShinX, cy + 50 * s, 16 * s, pivotLeft ? '#22d3ee' : '#475569'); 
                        drawSegment(leftShinX, cy + 50 * s, cx - 25 * s, footY, 16 * s, pivotLeft ? '#22d3ee' : '#475569');
                        const rightShinX = cx + 15 * s - (pivotLeft ? 0 : kneeBend);
                        drawSegment(cx + 15 * s, hipY, rightShinX, cy + 50 * s, 16 * s, !pivotLeft ? '#22d3ee' : '#475569');
                        drawSegment(rightShinX, cy + 50 * s, cx + 25 * s, footY, 16 * s, !pivotLeft ? '#22d3ee' : '#475569');
                        
                        // Torso Twist with curve
                        ctx.save(); ctx.translate(cx, hipY); ctx.rotate(rot * 0.025);
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(5 * s * rotPhase, -30 * s, 0, -60 * s); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke(); 
                        ctx.restore();
                        
                        ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        const handsX = cx + rot * 1.5; const handsY = hipY - 50 * s + Math.abs(rot) * 0.5;

                        // Barbell anchored on ground with slight flex
                        const anchorX = cx - 80 * s; const anchorY = footY;
                        const barMidX = (anchorX + handsX) / 2 + Math.sin(t * 2) * 2 * s; // Slight vibration for realism
                        const barMidY = (anchorY + handsY) / 2;
                        ctx.beginPath(); ctx.moveTo(anchorX, anchorY); ctx.quadraticCurveTo(barMidX, barMidY, handsX, handsY); ctx.strokeStyle = '#64748b'; ctx.lineWidth = 6; ctx.stroke();
                        ctx.fillStyle = '#1e293b'; ctx.beginPath(); ctx.arc(anchorX, anchorY, 10 * s, 0, Math.PI); ctx.fill();

                        drawSegment(cx, hipY - 50 * s, handsX, handsY, 8 * s, '#cbd5e1');
                        
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("LANDMINE TWIST", 20, 30);
                        // Actionable cue: Pivot feet
                        if (rotPhase > 0.7) {
                            drawForce(cx, footY, pivotLeft ? -1 : 1, 0, "PIVOT");
                        }
                    }
                    else if (type === 'band_twist') {
                        // REFINED: Looks like Pallof but rotates
                        const twistPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                        const twist = twistPhase * 35 * s;
                        const hipY = cy + 20 * s; 
                        const cableX = cx - 100 * s; const cableY = cy - 20 * s;

                        // Static Stance (Pallof Base) with slight knee flex
                        const kneeFlex = 3 * s * twistPhase;
                        drawSegment(cx - 15 * s, hipY, cx - 20 * s, cy + 50 * s + kneeFlex, 16 * s, '#475569');
                        drawSegment(cx - 20 * s, cy + 50 * s + kneeFlex, cx - 20 * s, cy + 100 * s, 16 * s, '#475569');
                        drawSegment(cx + 15 * s, hipY, cx + 20 * s, cy + 50 * s - kneeFlex, 16 * s, '#475569');
                        drawSegment(cx + 20 * s, cy + 50 * s - kneeFlex, cx + 20 * s, cy + 100 * s, 16 * s, '#475569');
                        
                        ctx.save(); ctx.translate(cx, hipY); ctx.rotate(twist * 0.02);
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.quadraticCurveTo(3 * s * twistPhase, -30 * s, 0, -60 * s); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke(); 
                        ctx.restore();
                        
                        // Hands follow rotation with grip
                        const handsX = cx + twist * 1.5; 
                        drawSegment(cx, hipY - 50 * s, handsX, hipY - 50 * s, 8 * s, '#cbd5e1'); 
                        ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        
                        // Band line from anchor to hands with stretch effect
                        const bandMidX = (cableX + handsX) / 2 + Math.sin(t * 5) * 2 * s; // Vibration for tension
                        const bandMidY = (cableY + hipY - 50 * s) / 2;
                        ctx.beginPath(); ctx.moveTo(cableX, cableY); ctx.quadraticCurveTo(bandMidX, bandMidY, handsX, hipY - 50 * s); ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 3 + twistPhase; ctx.stroke();
                        ctx.fillStyle = '#334155'; ctx.fillRect(cableX - 10 * s, hipY - 70 * s, 10 * s, 40 * s); // Anchor

                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("BAND TWIST", 20, 30);
                        // Actionable cue: Resist twist
                        drawForce(handsX, hipY - 50 * s, -1, 0, "RESIST");
                    }
                    else if (type === 'wall_throw') {
                        // NEW: Rotational Wall Throw
                        const wallX = cx + 80 * s;
                        ctx.fillStyle = '#334155'; ctx.fillRect(wallX, 0, 10 * s, h); // Wall
                        
                        const phase = easeInOutCubic(((t * 1.5) % 2) / 2); // Smoother phase
                        const isThrowing = phase > 0.5 && phase < 0.65;
                        const rotPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                        const rot = rotPhase * 25 * s;
                        const hipY = cy + 20 * s;
                        
                        drawSegment(cx - 15 * s, hipY, cx - 20 * s, cy + 100 * s, 16 * s, '#475569');
                        drawSegment(cx + 15 * s, hipY, cx + 20 * s, cy + 100 * s, 16 * s, isThrowing ? '#22d3ee' : '#475569');

                        ctx.save(); ctx.translate(cx, hipY); ctx.rotate(rot * 0.03);
                        drawSegment(0, 0, 0, -60 * s, 16 * s, '#22d3ee');
                        ctx.restore();
                        
                        const handsX = cx + rot * 1.5;
                        drawSegment(cx, hipY - 50 * s, handsX, hipY - 50 * s, 8 * s, '#cbd5e1');
                        ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                        // Ball Physics with bounce on wall
                        let ballX = handsX + 15 * s;
                        let ballY = hipY - 50 * s + Math.sin(t * 10) * 2 * s; // Slight vertical bob
                        if (isThrowing) {
                            ballX += (phase - 0.5) * 300 * s; // Faster fly to wall
                            if (ballX >= wallX - 8 * s) { // Bounce back
                                ballX = wallX - 8 * s - (phase - 0.6) * 50 * s;
                                ballY += Math.sin((phase - 0.6) * Math.PI * 5) * 10 * s; // Bounce arc
                            }
                            drawForce(ballX, ballY, 1, 0, "RELEASE");
                        }
                        drawEquipment('ball', ballX, ballY, t * 2); // Rotate ball for realism
                        
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("ROTATIONAL WALL THROW", 20, 30);
                        // Actionable cue: Rotate hips
                        if (isThrowing) {
                            drawForce(cx, hipY, rot > 0 ? 1 : -1, 0, "ROTATE HIPS");
                        }
                    }
                    else if (type === 'med_ball_slam') {
    const phase = easeInOutCubic(((t * 2.2) % 2) / 2);  // Slightly faster cycle for explosiveness
    const isLifting = phase < 0.4;
    const isTop = phase >= 0.4 && phase < 0.5;
    const isSlamming = phase >= 0.5 && phase < 0.7;
    const isImpact = phase >= 0.7 && phase < 0.8;
    const isRebound = phase >= 0.8;

    const hipY = cy + 20 * s;
    const shY = cy - 40 * s;

    // Torso rotation + hip drive for power
    const torsoRot = isSlamming ? (phase - 0.5) * Math.PI / 3 : isLifting ? -(0.4 - phase) * Math.PI / 6 : 0;
    ctx.save();
    ctx.translate(cx, hipY);
    ctx.rotate(torsoRot);
    drawSegment(0, -60 * s, 0, 20 * s, 18 * s, '#475569');  // Thick neutral spine
    ctx.restore();

    // Ball position with realistic arc
    let ballX, ballY;
    if (isLifting) {
        // Rising overhead with slight backward arc
        ballX = cx - (0.4 - phase) * 40 * s;
        ballY = shY - 100 * s - (0.4 - phase) * 60 * s;
    } else if (isTop) {
        ballX = cx;
        ballY = shY - 140 * s;  // Peak overhead
    } else if (isSlamming) {
        // Explosive forward/downward arc
        const slamProgress = (phase - 0.5) / 0.2;
        ballX = cx + slamProgress * 60 * s;
        ballY = shY - 140 * s + slamProgress * slamProgress * 300 * s;  // Parabolic drop
    } else if (isImpact) {
        ballX = cx + 60 * s;
        ballY = hipY + 80 * s;  // Ground impact
    } else {
        // Small rebound bounce
        const reboundHeight = (1 - phase) * 30 * s;
        ballX = cx + 60 * s;
        ballY = hipY + 80 * s - reboundHeight;
    }

    // Arms driving the movement with elbow bend
    const elbowBend = isSlamming ? 20 * s : 10 * s;
    const leftElbowX = cx - 20 * s - (isSlamming ? (phase - 0.5) * 40 * s : 0);
    const leftElbowY = shY + (isSlamming ? (phase - 0.5) * 100 * s : 0);
    ctx.beginPath();
    ctx.moveTo(cx - 15 * s, shY);
    ctx.quadraticCurveTo(leftElbowX, leftElbowY, ballX - 10 * s, ballY);
    ctx.strokeStyle = '#38bdf8';
    ctx.lineWidth = 10 * s;
    ctx.stroke();

    const rightElbowX = cx + 20 * s + (isSlamming ? (phase - 0.5) * 40 * s : 0);
    const rightElbowY = shY + (isSlamming ? (phase - 0.5) * 100 * s : 0);
    ctx.beginPath();
    ctx.moveTo(cx + 15 * s, shY);
    ctx.quadraticCurveTo(rightElbowX, rightElbowY, ballX + 10 * s, ballY);
    ctx.stroke();

    // Ball with spin + glow on impact
    ctx.save();
    if (isImpact || isRebound) {
        ctx.shadowBlur = 30;
        ctx.shadowColor = "#f59e0b";
    }
    drawEquipment('ball', ballX, ballY, t * (isSlamming ? 8 : 3));  // Faster spin during slam
    ctx.restore();

    // Legs — explosive hip/knee flexion on slam
    const kneeFlex = isSlamming ? (phase - 0.5) * 30 * s : 0;
    drawSegment(cx - 15 * s, hipY, cx - 20 * s, hipY + 60 * s + kneeFlex, 16 * s, '#22d3ee');
    drawSegment(cx + 15 * s, hipY, cx + 20 * s, hipY + 60 * s + kneeFlex, 16 * s, '#22d3ee');

    ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

    // Text + cues
    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("MED BALL POWER SLAM", 20, 30);
    
    if (isLifting) {
        drawForce(cx, shY - 100 * s, 0, -1, "TRIPLE EXTENSION");
    } else if (isSlamming) {
        drawForce(ballX, ballY, 0.7, 1, "EXPLOSIVE HIP DRIVE");
    } else if (isImpact) {
        ctx.save(); ctx.globalAlpha = 0.8 + Math.sin(t * 20) * 0.2;
        ctx.fillStyle = '#f59e0b'; ctx.font = 'bold 16px sans-serif'; ctx.fillText("IMPACT!", cx - 40, cy + 100);
        ctx.restore();
    }
}
                    else if (type === 'weck_pulse') {
                        const pulsePhase = easeInOutCubic(Math.abs(Math.sin(t * 4))); 
                        const pulse = pulsePhase * 5 * s; 
                        const hipY = cy + pulse; 
                        drawSegment(cx, hipY, cx - 20 * s, cy + 80 * s, 16 * s, '#475569'); 
                        drawSegment(cx, hipY, cx + 20 * s, cy + 80 * s, 16 * s, '#475569');
                        drawSegment(cx, hipY, cx, hipY - 60 * s, 16 * s, '#22d3ee'); 
                        ctx.beginPath(); ctx.arc(cx, hipY - 75 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        const headX = cx; const footX = cx + 20 * s;
                        ctx.strokeStyle = '#22d3ee'; ctx.setLineDash([2, 2]); ctx.beginPath(); ctx.moveTo(headX, hipY - 75 * s); ctx.lineTo(footX, cy + 80 * s); ctx.stroke();
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("DOUBLE DOWN PULSE", 20, 30);
                        // Actionable cue: Pulse highlight
                        ctx.save(); ctx.globalAlpha = pulsePhase; ctx.fillStyle = '#22d3ee'; ctx.fillRect(cx - 10 * s, hipY, 20 * s, -60 * s);
                        ctx.restore();
                    }
                    else if (type === 'towel_curl') {
                        const footY = cy + 60 * s; const ankleX = cx; 
                        const heelX = ankleX - 25 * s; const toeX = ankleX + 35 * s;
                        const lift = 10 * s; 
                        const towelY = footY + 5 * s;
                        const crunchPhase = easeInOutCubic(Math.abs(Math.sin(t * 3)));
                        const crunch = crunchPhase * 15 * s;
                        drawEquipment('towel', toeX, towelY, 0);
                        ctx.beginPath(); ctx.moveTo(toeX + 20 * s, towelY);
                        ctx.quadraticCurveTo(toeX, towelY - crunch, toeX - 30 * s, towelY);
                        ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 6; ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(heelX, footY - lift); 
                        ctx.quadraticCurveTo(ankleX, footY - lift - 15 * s, toeX, footY); 
                        ctx.lineWidth = 4; ctx.strokeStyle = '#38bdf8'; ctx.stroke();
                        const toeCurlPhase = easeInOutCubic(Math.abs(Math.sin(t * 3)));
                        const toeCurl = toeCurlPhase * 8 * s;
                        ctx.beginPath(); ctx.moveTo(toeX, footY); 
                        ctx.quadraticCurveTo(toeX + 10 * s, footY - 10 * s, toeX - toeCurl, footY + 5 * s);
                        ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 4; ctx.stroke();
                        drawMuscle(toeX, footY, toeX - toeCurl, footY + 5 * s, 6 * s, true, "TOE SCRUNCH", 'left');
                        ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("SCRUNCH TOWEL", cx - 80 * s, cy - 20 * s);
                        drawForce(toeX, footY, -1, 0.2, ""); 
                        // Actionable cue: Toe curl pulse
                        if (toeCurlPhase > 0.5) {
                            ctx.save(); ctx.globalAlpha = 0.5 + Math.sin(t * 5) * 0.3;
                            drawForce(toeX - toeCurl, footY + 5 * s, -1, 0, "PULL TOWEL");
                            ctx.restore();
                        }
                    }
                    else if (type === 'pallof_press') {
                        const cableX = cx - 80 * s; const cableY = cy;
                        const bodyX = cx + 20 * s; const bodyY = cy + 40 * s;
                        const pressPhase = easeInOutCubic(Math.abs(Math.sin(t * 2.5)));
                        const press = pressPhase * 30 * s;
                        ctx.fillStyle = '#334155'; ctx.fillRect(cableX - 5 * s, cableY - 40 * s, 10 * s, 80 * s);
                        drawSegment(bodyX, bodyY, bodyX, bodyY - 70 * s, 16 * s, '#475569'); 
                        ctx.beginPath(); ctx.arc(bodyX, bodyY - 90 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill(); 
                        const handX = bodyX; const handY = bodyY - 40 * s;
                        const lArmBend = pressPhase * 5 * s; const lElbowX = bodyX - 10 * s - lArmBend; const lElbowY = bodyY - 60 * s;
                        ctx.beginPath(); ctx.moveTo(bodyX - 10 * s, bodyY - 60 * s); ctx.quadraticCurveTo(lElbowX, lElbowY, handX - press, handY); ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 6 * s; ctx.stroke();
                        const rArmBend = pressPhase * -5 * s; const rElbowX = bodyX + 10 * s - rArmBend; const rElbowY = bodyY - 60 * s;
                        ctx.beginPath(); ctx.moveTo(bodyX + 10 * s, bodyY - 60 * s); ctx.quadraticCurveTo(rElbowX, rElbowY, handX - press, handY); ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 6 * s; ctx.stroke();
                        ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2 + pressPhase; ctx.beginPath(); ctx.moveTo(cableX, cableY); ctx.lineTo(handX - press, handY); ctx.stroke();
                        drawMuscle(bodyX + 8 * s, bodyY - 20 * s, bodyX + 8 * s, bodyY - 60 * s, 10 * s, true, "ANTI-ROTATION", 'right');
                        drawForce(handX - press, handY, 1, 0, "LATERAL FORCE");
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("PALLOF PRESS", 20, 30);
                        // Actionable cue: Brace core
                        if (pressPhase > 0.5) {
                            ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#22d3ee'; ctx.fillRect(bodyX - 10 * s, bodyY - 40 * s, 20 * s, 40 * s);
                            ctx.fillStyle = '#000'; ctx.font = 'bold 8px sans-serif'; ctx.fillText("BRACE", bodyX - 15 * s, bodyY - 20 * s);
                            ctx.restore();
                        }
                    }
                    else if (type === 'head_loading_basic' || type === 'head_loading') {  // Basic standing
    const headX = cx; const headY = cy - 40 * s;
    drawEquipment('ball', headX, headY - 28 * s, 0);
    const shoulderY = headY + 20 * s;
    drawSegment(headX + 20 * s, shoulderY, headX + 10 * s, headY - 40 * s, 8 * s, '#38bdf8'); 
    drawSegment(headX - 20 * s, shoulderY, headX - 10 * s, headY - 40 * s, 8 * s, '#38bdf8'); 
    drawMuscle(headX, headY + 10 * s, headX, headY + 60 * s, 10 * s, true, "AXIAL LOAD");
    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("BASIC HEAD LOADING", 20, 30);
    drawForce(headX, headY - 20 * s, 0, 1, "GRAVITY");
}
else if (type === 'head_hinge') {  // Improved Hip Hinge - more realistic posterior shift
    const phase = easeInOutCubic((Math.sin(t * 1.8) + 1) / 2);  // Slower, smoother hinge
    const hingeAngle = phase * 50 * (Math.PI / 180);  // Up to ~50° for deeper hinge
    const hipShiftBack = phase * 30 * s;  // Butt pushes back for realism
    
    // Hips move back as we hinge
    const hipX = cx + hipShiftBack;
    const headX = hipX + Math.sin(hingeAngle) * 60 * s;
    const headY = cy - 40 * s - Math.cos(hingeAngle) * 60 * s;  // Head drops slightly but stays loaded
    
    drawEquipment('ball', headX, headY - 28 * s, 0);
    
    // Torso (spine) hinged from hips
    ctx.save();
    ctx.translate(hipX, cy);
    ctx.rotate(hingeAngle);
    drawSegment(0, -60 * s, 0, 20 * s, 18 * s, '#475569');  // Thicker neutral spine
    ctx.restore();
    
    // Legs straight, slight knee soften on hinge
    const kneeSoft = phase * 5 * s;
    drawSegment(hipX - 20 * s, cy, hipX - 20 * s, cy + 100 * s + kneeSoft, 16 * s, '#22d3ee');
    drawSegment(hipX + 20 * s, cy, hipX + 20 * s, cy + 100 * s + kneeSoft, 16 * s, '#22d3ee');
    
    // Arms hanging naturally or on hips
    drawSegment(hipX - 25 * s, cy + 10 * s, hipX - 45 * s + phase * 10 * s, cy + 40 * s, 8 * s, '#cbd5e1');
    drawSegment(hipX + 25 * s, cy + 10 * s, hipX + 45 * s - phase * 10 * s, cy + 40 * s, 8 * s, '#cbd5e1');
    
    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED HIP HINGE", 20, 30);
    drawForce(hipX, cy + 60 * s, 1, 0, "PUSH BUTT BACK");  // Better cue
}
else if (type === 'head_split') {  // Split Squat
    const phase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
    const depth = phase * 30 * s;
    const headX = cx; const headY = cy - 80 * s + depth;
    drawEquipment('ball', headX, headY - 28 * s, 0);
    const frontKneeX = cx + 40 * s; const frontFootX = cx + 60 * s;
    drawSegment(cx, cy + depth, frontKneeX, cy + 40 * s + depth, 16 * s, '#22d3ee');
    drawSegment(frontKneeX, cy + 40 * s + depth, frontFootX, cy + 100 * s, 16 * s, '#22d3ee');
    drawSegment(cx, cy + depth, cx - 40 * s, cy + 60 * s + depth / 2, 16 * s, '#475569');
    drawSegment(cx - 40 * s, cy + 60 * s + depth / 2, cx - 60 * s, cy + 100 * s, 10 * s, '#475569');
    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED SPLIT SQUAT", 20, 30);
}
else if (type === 'head_coiling') {  // Coiling (simple version)
    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED COILING", 20, 30);
    // (reuses coiling_lunge logic + ball on head - you already have coiling_lunge, so it will look good)
}
else if (type === 'head_march') {
    const marchCycle = Math.sin(t * 5);  // Faster, smoother march
    const leftKneeUp = marchCycle > 0 ? Math.abs(marchCycle) * 45 * s : 0;
    const rightKneeUp = marchCycle < 0 ? Math.abs(marchCycle) * 45 * s : 0;
    
    const headX = cx + Math.sin(t * 5) * 4 * s;  // Tiny natural sway
    const headY = cy - 40 * s;
    drawEquipment('ball', headX, headY - 28 * s, 0);
    
    // Upright torso
    drawSegment(cx, cy - 20 * s, cx, cy + 40 * s, 18 * s, '#475569');
    
    // Left leg - marches when right is down
    const leftThighY = cy + 40 * s + leftKneeUp * 0.5;
    drawSegment(cx - 15 * s, cy + 40 * s, cx - 15 * s, leftThighY, 16 * s, leftKneeUp > 0 ? '#22d3ee' : '#475569');
    drawSegment(cx - 15 * s, leftThighY, cx - 20 * s, cy + 90 * s + leftKneeUp * 0.8, 14 * s, leftKneeUp > 0 ? '#22d3ee' : '#475569');
    
    // Right leg
    const rightThighY = cy + 40 * s + rightKneeUp * 0.5;
    drawSegment(cx + 15 * s, cy + 40 * s, cx + 15 * s, rightThighY, 16 * s, rightKneeUp > 0 ? '#22d3ee' : '#475569');
    drawSegment(cx + 15 * s, rightThighY, cx + 20 * s, cy + 90 * s + rightKneeUp * 0.8, 14 * s, rightKneeUp > 0 ? '#22d3ee' : '#475569');
    
    ctx.beginPath(); ctx.arc(headX, headY, 20 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HEAD-LOADED MARCH", 20, 30);
    drawForce(headX, headY, 0, 0.3, "STABLE CORE");
}
                    else if (type === 'hft_swing') {
                        const hipY = cy; const kneeY = cy + 60 * s; const footY = cy + 100 * s;
                        drawSegment(cx - 10 * s, hipY, cx - 10 * s, footY, 6 * s, '#475569');
                        const swingPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                        const swing = swingPhase * 30 * s;
                        const kneeBend = swingPhase * 5 * s; // Bend knee during swing
                        const kneeX = cx + 10 * s + swing / 2;
                        const kneePosY = kneeY + kneeBend;
                        ctx.beginPath(); ctx.moveTo(cx + 10 * s, hipY); ctx.quadraticCurveTo(kneeX, kneePosY, cx + 10 * s + swing, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();
                        ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("TOE TENSION", cx - 10 * s, footY + 20 * s);
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("HFT KINETIC SWING", 20, 30);
                         drawForce(cx + 10 * s + swing, footY, swing > 0 ? 1 : -1, 0, "MOMENTUM");
                         // Actionable cue: Toe tension highlight
                         if (swingPhase > 0.6) {
                             ctx.save(); ctx.globalAlpha = 0.7; ctx.fillStyle = '#22d3ee'; ctx.beginPath(); ctx.arc(cx + 10 * s + swing, footY, 5 * s, 0, 2 * Math.PI); ctx.fill();
                             ctx.restore();
                         }
                    }
                    else if (type === 'coiling_lunge') {
                        const lungePhase = easeInOutCubic((Math.sin(t * 1) + 1) / 2); // Slower, smoother lunge
                        const lunge = lungePhase * 20 * s; 
                        const footY = cy + 80 * s;
                        const kneeY = cy + 20 * s + lunge;
                        const hipY = cy - 20 * s + lunge;
                        const backFootX = cx - 60 * s;
                        drawSegment(cx, hipY, backFootX + 20 * s, cy + 40 * s + lunge / 2, 16 * s, '#475569'); 
                        drawSegment(backFootX + 20 * s, cy + 40 * s + lunge / 2, backFootX, footY, 10 * s, '#475569');
                        const frontFootX = cx + 40 * s;
                        const frontKneeX = frontFootX + 20 * s;
                        drawSegment(cx, hipY, frontKneeX, kneeY, 14 * s, '#f97316'); 
                        drawSegment(frontKneeX, kneeY, frontFootX, footY, 16 * s, '#f97316');
                        const coilPhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                        const coil = coilPhase * 15 * s; 
                        const headX = frontFootX + coil * 0.2; // Slight head movement
                        const headY = cy - 85 * s + coil;
                        ctx.beginPath();
                        ctx.moveTo(cx, hipY);
                        ctx.quadraticCurveTo(cx + 10 * s, cy - 40 * s, headX - 5 * s, headY + 15 * s); 
                        ctx.lineWidth = 16 * s;
                        ctx.strokeStyle = '#475569';
                        ctx.stroke();
                        ctx.beginPath(); ctx.arc(headX, headY, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        ctx.save();
                        ctx.strokeStyle = '#22d3ee';
                        ctx.setLineDash([4,4]);
                        ctx.beginPath();
                        ctx.moveTo(headX, headY);
                        ctx.lineTo(frontFootX, footY);
                        ctx.stroke();
                        ctx.restore();
                        ctx.fillStyle = '#f97316'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("HEAD OVER FOOT", headX + 15 * s, headY);
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("COILING LUNGE", 20, 30);
                        // Actionable cue: Coil pulse
                        if (coilPhase > 0.5) {
                            ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#f97316'; ctx.fillRect(headX - 10 * s, headY, 20 * s, 15 * s);
                            ctx.restore();
                        }
                    }
                    else if (type === 'shoulder_release') {
                        const headX = cx, headY = cy - 60 * s, shY = cy - 40 * s, shL = cx - 25 * s, shR = cx + 25 * s;
                        drawSegment(cx, shY, cx, cy + 50 * s, 14 * s, '#475569'); drawSegment(shL, shY, shR, shY, 4 * s);
                        ctx.beginPath(); ctx.arc(headX, headY, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill(); 
                        drawMuscle(shR, shY, headX, headY + 10 * s, 15 * s, cycle > 0, "TISSUE RELEASE");
                        const ballRoll = Math.sin(t * 2) * 3 * s; // Rolling motion
                        drawEquipment('smash_ball', shR - 8 * s + ballRoll, shY - 5 * s, t * 2); // Rotate ball
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SOFT TISSUE MOBILIZATION", 20, 30);
                        // Actionable cue: Breathe label
                        ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("BREATHE DEEP", shR + 10 * s, shY);
                    }
                    else if (type === 'foot_roll') {
                        const footY = cy + 80 * s; const ankleX = cx; 
                        // Draw Foot with arch curve
                        const heelX = ankleX - 20 * s; const toeX = ankleX + 20 * s;
                        const archPhase = Math.sin(t * 2) * 5 * s; // Arch flex
                        ctx.beginPath(); ctx.moveTo(heelX, footY); ctx.quadraticCurveTo(ankleX, footY - 10 * s - archPhase, toeX, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke(); 
                        
                        // Draw Leg (Standing) with slight bend
                        const kneeY = cy + 20 * s; const hipY = cy - 40 * s;
                        const shinBend = Math.sin(t * 2) * 2 * s;
                        ctx.beginPath(); ctx.moveTo(ankleX, footY); ctx.quadraticCurveTo(ankleX + shinBend, (footY + kneeY) / 2, ankleX, kneeY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 10 * s; ctx.stroke(); // Shin
                        ctx.beginPath(); ctx.moveTo(ankleX, kneeY); ctx.quadraticCurveTo(ankleX - shinBend, (kneeY + hipY) / 2, ankleX, hipY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke(); // Thigh
                        
                        // Draw Torso/Head with slight lean
                        const headY = hipY - 50 * s;
                        const torsoLean = Math.sin(t * 2) * 3 * s;
                        ctx.beginPath(); ctx.moveTo(ankleX, hipY); ctx.quadraticCurveTo(ankleX + torsoLean / 2, (hipY + headY) / 2, ankleX + torsoLean, headY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 14 * s; ctx.stroke(); // Torso
                        ctx.beginPath(); ctx.arc(ankleX + torsoLean, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();

                        const ballPosPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                        const ballPos = ballPosPhase * 20 * s - 10 * s; 
                        drawEquipment('smash_ball', ankleX + ballPos, footY + 5 * s, t * 2); // Rolling ball
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("PLANTAR RELEASE", 20, 30);
                        // Actionable cue: Pressure point
                        ctx.save(); ctx.globalAlpha = 0.5 + Math.cos(t * 3) * 0.3; ctx.beginPath(); ctx.arc(ankleX + ballPos, footY + 5 * s, 8 * s, 0, 2 * Math.PI); ctx.fillStyle = '#f43f5e'; ctx.fill();
                        ctx.restore();
                    }
                    else if (type === 'spinal_wave') {
                        const ballX = cx, ballY = cy + 40 * s; drawEquipment('swiss', ballX, ballY, 0);
                        const curvePhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                        const curve = 30 * s + (curvePhase * 30 * s); // Deeper curve
                        const bodyColor = curvePhase > 0.5 ? '#22d3ee' : '#475569';
                        ctx.beginPath(); ctx.moveTo(cx - 40 * s, cy + 40 * s); ctx.quadraticCurveTo(cx, cy - curve, cx + 40 * s, cy + 40 * s); 
                        ctx.lineWidth = 14 * s; ctx.strokeStyle = bodyColor; ctx.lineCap = 'round'; ctx.stroke();
                        ctx.beginPath(); ctx.arc(cx - 45 * s, cy + 35 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill(); // Head
                        if (curvePhase > 0.5) { ctx.fillStyle = '#22c55e'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("SEGMENTATION", cx - 20 * s, cy - 60 * s); }
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("SPINAL WAVE", 20, 30);
                        // Actionable cue: Wave direction
                        drawForce(cx, cy, curvePhase > 0.5 ? 0 : 0, curvePhase > 0.5 ? -1 : 1, "WAVE UP");
                    }
                    else if (type === 'hyperarch_hop') {
                        const hopPhase = easeInOutCubic(Math.abs(Math.sin(t * 3))); // Half speed for control
                        const hop = hopPhase * 15 * s; 
                        const footY = cy + 80 * s - hop; const hipY = cy - 60 * s - hop;
                        const ankleFlex = hopPhase * 5 * s; // Ankle dorsiflexion
                        const leftAnkleY = footY - ankleFlex; const leftAnkleX = cx - 10 * s;
                        ctx.beginPath(); ctx.moveTo(cx - 10 * s, hipY); ctx.quadraticCurveTo(cx - 10 * s, (hipY + leftAnkleY) / 2, leftAnkleX, leftAnkleY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(leftAnkleX, leftAnkleY); ctx.lineTo(cx - 10 * s, footY); ctx.stroke(); // Foot
                        const rightAnkleY = footY + ankleFlex; const rightAnkleX = cx + 10 * s;
                        ctx.beginPath(); ctx.moveTo(cx + 10 * s, hipY); ctx.quadraticCurveTo(cx + 10 * s, (hipY + rightAnkleY) / 2, rightAnkleX, rightAnkleY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 6 * s; ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(rightAnkleX, rightAnkleY); ctx.lineTo(cx + 10 * s, footY); ctx.stroke();
                        drawSegment(cx, hipY, cx, hipY - 60 * s, 14 * s, '#475569');
                        if (hop > 5 * s) { ctx.fillStyle = '#22d3ee'; ctx.font = 'bold 10px sans-serif'; ctx.fillText("LOCKED ANKLE", cx + 20 * s, footY); }
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("2-FOOT FASCIAL HOP", 20, 30);
                        drawForce(cx, footY, 0, -1, "RECOIL");
                        // Actionable cue: Heel suspend
                        ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(cx, footY - 5 * s, 3 * s, 0, 2 * Math.PI); ctx.fill(); // Heel point
                        ctx.restore();
                    }
                    else if (type === 'standing_pull') {
                        const hipY = cy + 20 * s; const footY = cy + 100 * s;
                        drawSegment(cx - 15 * s, hipY, cx - 20 * s, footY, 16 * s, '#475569'); 
                        drawSegment(cx + 15 * s, hipY, cx + 20 * s, footY, 16 * s, '#475569');
                        drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#22d3ee'); // Torso
                        ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        const pullPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2);
                        const pull = pullPhase * 20 * s;
                        // Arms pulling back from high cable with elbow flare
                        const cableX = cx - 80 * s; const cableY = hipY - 100 * s;
                        const elbowX = cx - 30 * s - Math.abs(pull) + pullPhase * 5 * s; const handX = cx + 20 * s + pullPhase * 10 * s; const handY = hipY - 80 * s - pullPhase * 5 * s;
                        
                        ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 2 + pullPhase; ctx.beginPath(); ctx.moveTo(cableX, cableY); ctx.lineTo(handX, handY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(cx, hipY - 60 * s); ctx.quadraticCurveTo(elbowX, hipY - 70 * s, handX, handY); ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth = 8 * s; ctx.stroke();
                        drawMuscle(cx, hipY - 60 * s, elbowX, hipY - 70 * s, 16 * s, true, "RHOMBOID", 'left');
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("CABLE FACE PULL", 20, 30);
                        // Actionable cue: Squeeze blades
                        if (pullPhase > 0.7) {
                            ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#22d3ee'; ctx.fillRect(cx - 20 * s, hipY - 70 * s, 40 * s, 20 * s);
                            ctx.fillStyle = '#000'; ctx.font = 'bold 8px sans-serif'; ctx.fillText("SQUEEZE", cx - 15 * s, hipY - 60 * s);
                            ctx.restore();
                        }
                    }
                    else if (type === 'inversion_hang') {
                        // ENHANCED: Dynamic hang with progression cues - hang, twist, leg swing/pull-up
                        const hangPhase = easeInOutCubic((Math.sin(t * 1.5) + 1) / 2);
                        const hangDrop = hangPhase * 40 * s; // Drop from bar
                        const barY = cy - 100 * s;
                        drawEquipment('pullup_bar', cx, barY, 0);
                        const handY = barY + 10 * s; // Grip
                        const torsoY = handY + 20 * s + hangDrop;
                        const hipY = torsoY + 40 * s;
                        const kneeY = hipY + 30 * s + hangDrop * 0.5;
                        const footY = kneeY + 40 * s;
                        // Arms hanging straight
                        drawSegment(cx - 10 * s, handY, cx - 10 * s, torsoY, 8 * s, '#22d3ee');
                        drawSegment(cx + 10 * s, handY, cx + 10 * s, torsoY, 8 * s, '#22d3ee');
                        // Torso relaxed hang
                        ctx.beginPath(); ctx.moveTo(cx - 15 * s, torsoY); ctx.quadraticCurveTo(cx, torsoY + 10 * s, cx + 15 * s, torsoY); ctx.strokeStyle = '#475569'; ctx.lineWidth = 16 * s; ctx.stroke();
                        // Head
                        ctx.beginPath(); ctx.arc(cx, torsoY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        // Legs swinging for level 3 cue
                        const swingPhase = easeInOutCubic((Math.sin(t * 3) + 1) / 2);
                        const legSwing = swingPhase * 20 * s - 10 * s;
                        const leftKneeX = cx - 15 * s + legSwing; const leftFootX = cx - 25 * s + legSwing * 1.5;
                        ctx.beginPath(); ctx.moveTo(cx - 10 * s, hipY); ctx.quadraticCurveTo(leftKneeX, kneeY, leftFootX, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 10 * s; ctx.stroke();
                        const rightKneeX = cx + 15 * s - legSwing; const rightFootX = cx + 25 * s - legSwing * 1.5;
                        ctx.beginPath(); ctx.moveTo(cx + 10 * s, hipY); ctx.quadraticCurveTo(rightKneeX, kneeY, rightFootX, footY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 10 * s; ctx.stroke();
                        // Twist for level 2
                        if (hangPhase > 0.5) {
                            ctx.save(); ctx.translate(cx, torsoY); ctx.rotate(Math.sin(t * 2) * 0.2); ctx.beginPath(); ctx.arc(0, -15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill(); ctx.restore();
                            drawForce(cx, torsoY, Math.sin(t * 2) > 0 ? 1 : -1, 0, "TWIST");
                        }
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("INVERSION HANG & SWING", 20, 30);
                        // Actionable cue: Relax/ swing
                        drawForce(cx, footY, legSwing > 0 ? 1 : -1, 0, "LEG SWING");
                    }
                    else if (type === 'diaphragm_breath') {
                        // ENHANCED: Breathing with torso expansion/contraction, integrated flow
                        const breathPhase = easeInOutCubic((Math.sin(t * 2) + 1) / 2); // Inhale 0-1
                        const expand = breathPhase * 20 * s; // Torso width
                        const hipY = cy + 20 * s;
                        const footY = cy + 100 * s;
                        drawSegment(cx - 10 * s, footY, cx, hipY, 16 * s, '#475569');
                        drawSegment(cx + 10 * s, footY, cx, hipY, 16 * s, '#475569');
                        // Torso expands/contracts with breath
                        const torsoWidth = 30 * s + expand;
                        ctx.save(); ctx.translate(cx, hipY); ctx.scale(1 + (expand / 100), 1); ctx.beginPath(); ctx.ellipse(0, -35 * s, torsoWidth / 2, 35 * s, 0, 0, 2 * Math.PI); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 16 * s; ctx.stroke(); ctx.restore();
                        const headY = hipY - 70 * s;
                        ctx.beginPath(); ctx.arc(cx, headY - 15 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        // Arms relaxed, slight raise on inhale
                        const armRise = breathPhase * 10 * s;
                        drawSegment(cx - 15 * s, headY + 10 * s, cx - 20 * s, headY + 30 * s - armRise, 8 * s, '#475569');
                        drawSegment(cx + 15 * s, headY + 10 * s, cx + 20 * s, headY + 30 * s - armRise, 8 * s, '#475569');
                        // Diaphragm highlight pulsing
                        ctx.save(); ctx.globalAlpha = breathPhase; ctx.fillStyle = 'rgba(34, 211, 238, 0.4)'; ctx.fillRect(cx - 10 * s, hipY - 20 * s, 20 * s, 10 * s); ctx.restore();
                        drawMuscle(cx, hipY - 10 * s, cx, hipY + 10 * s, 16 * s, true, "DIAPHRAGM", 'right');
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("BREATH FLOW (EXPAND)", 20, 30);
                        // Actionable cue: Inhale/exhale
                        drawForce(cx, hipY, 0, breathPhase > 0.5 ? 1 : -1, breathPhase > 0.5 ? "EXHALE" : "INHALE");
                    }
                    else if (type === 'contra_pull') {
                        // ENHANCED: Explosive snap with quick recoil, hip drive
                        const pullPhase = easeInOutCubic((Math.sin(t * 4) + 1) / 2); // Faster for snap
                        const pull = pullPhase * 40 * s;
                        const recoil = Math.sin(t * 8) * 5 * s * pullPhase; // Quick snap back
                        const hipY = cy + 20 * s; const footY = cy + 100 * s;
                        // Contralateral stance: Right hand pull, left foot back
                        drawSegment(cx + 10 * s, footY, cx + 5 * s, hipY, 16 * s, '#475569');
                        drawSegment(cx - 20 * s, footY, cx - 10 * s, hipY, 16 * s, '#22d3ee'); // Emphasize back leg
                        drawSegment(cx, hipY, cx, hipY - 70 * s, 16 * s, '#475569');
                        ctx.beginPath(); ctx.arc(cx, hipY - 85 * s, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        // Band from anchor to hand
                        const anchorX = cx - 60 * s; const anchorY = hipY - 50 * s;
                        const handX = cx + pull - recoil; const handY = hipY - 50 * s;
                        ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 4 + pullPhase * 2; ctx.beginPath(); ctx.moveTo(anchorX, anchorY); ctx.lineTo(handX, handY); ctx.stroke();
                        // Arm explosive pull with elbow bend
                        const elbowX = (cx + handX) / 2 + Math.sin(t * 6) * 3 * s; const elbowY = handY + 5 * s * pullPhase;
                        ctx.beginPath(); ctx.moveTo(cx, hipY - 50 * s); ctx.quadraticCurveTo(elbowX, elbowY, handX, handY); ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 10 * s; ctx.stroke();
                        drawMuscle(cx, hipY - 50 * s, handX, handY, 16 * s, pullPhase > 0.7, "SNAP", 'right');
                        // Hip drive cue
                        if (pullPhase > 0.8) {
                            ctx.save(); ctx.globalAlpha = 0.7 + Math.sin(t * 10) * 0.3; drawForce(cx, hipY, 1, 0, "HIP DRIVE"); ctx.restore();
                        }
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("EXPLOSIVE CONTRA SNAP", 20, 30);
                        drawForce(handX, handY, -1, 0, "RECOIL");
                    }
                    else {
                        // FALLBACK: Generic Pulse
                        const pulsePhase = easeInOutCubic(Math.abs(Math.sin(t * 4)));
                        const pulse = pulsePhase * 5 * s;
                        drawSegment(cx, cy - 50 * s - pulse, cx, cy + 50 * s, 4 * s, '#475569'); 
                        ctx.beginPath(); ctx.arc(cx, cy - 60 * s - pulse, 16 * s, 0, 2 * Math.PI); ctx.fillStyle = '#cbd5e1'; ctx.fill();
                        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif'; ctx.fillText(type.toUpperCase().replace(/_/g, ' '), 20, 30);
                    }
                } catch (e) { } 
                if(playing) animationRef.current = requestAnimationFrame(loop);
            };
            loop();
            return () => cancelAnimationFrame(animationRef.current);
        }, [type, playing]);
        return <canvas ref={ref} className="w-full h-full bg-slate-950 rounded-lg shadow-inner" />;
    };

    const getGrade = (score) => {
        if (score >= 90) return 'A'; if (score >= 80) return 'B'; if (score >= 70) return 'C'; if (score >= 60) return 'D'; return 'F';
    };

    // --- NEW: Progress Streak Component (Retention Booster) ---
    const StreakTracker = ({ streakDays, onReset }) => (
        <div className="bg-gradient-to-r from-orange-500/20 to-red-500/20 border border-orange-500/30 rounded-lg p-4 mb-4">
            <div className="flex items-center justify-between mb-2">
                <div className="flex items-center gap-2">
                    <div className="text-orange-400 streak-flame"><Icons.Flame /></div>
                    <span className="text-sm font-bold text-orange-300">Current Streak</span>
                </div>
                {streakDays > 0 && <button onClick={onReset} className="text-xs text-orange-400 hover:text-orange-300">Reset</button>}
            </div>
            <div className="text-2xl font-black text-orange-400">{streakDays}</div>
            <div className="text-xs text-orange-300 mt-1">Days Consecutive Scans</div>
            {streakDays >= 7 && <div className="text-xs text-emerald-400 mt-1 font-bold"> On Fire! Bonus Protocol Unlocked</div>}
        </div>
    );

    // --- NEW: Goal Tracker Component (Retention Booster) ---
    const GoalTracker = ({ currentScore, targetScore, progress, onUpdateGoal }) => {
        const completion = Math.min(100, (currentScore / targetScore) * 100); const onTrack = currentScore >= targetScore * 0.8;

        return (
            <div className="bg-slate-900/50 border border-slate-700 rounded-lg p-4 mb-4">
                <div className="flex justify-between items-center mb-2">
                    <span className="text-sm font-bold text-slate-300">Goal: {targetScore}% Integrity</span>
                    <button onClick={onUpdateGoal} className="text-xs text-cyan-400 hover:text-cyan-300">Edit</button>
                </div>
                <div className="w-full bg-slate-800 rounded-full h-2 overflow-hidden mb-2">
                    <div className="goal-progress" style={{ width: `${completion}%` }} />
                </div>
{!onTrack && <div className="text-xs text-orange-400 mt-1 font-bold flex items-center gap-1"><Icons.Info /> Behind Pace — Protocol Adjusted for Easier Wins</div>}
                <div className="text-xs text-slate-400 flex justify-between">
                    <span>Current: {currentScore}%</span>
                    <span>{Math.round(completion)}% to Goal</span>
                </div>
                {completion >= 100 && <div className="text-xs text-emerald-400 mt-2 font-bold flex items-center gap-1"><Icons.Check /> Goal Achieved! Celebrate & Set New</div>}
            </div>
        );
    };

// ─────────────────────────────────────────────────────────────────────
    // THE UPGRADED ELITE COACH — V84.0 KINETIC VOICE ENGINE
    // ─────────────────────────────────────────────────────────────────────
    const ProgramPlayer = ({ program, onClose, onFeedback }) => {
        const [step, setStep] = useState(0);
        const [playing, setPlaying] = useState(true);
        const [timeLeft, setTimeLeft] = useState(program[0]?.duration || 60);
        const [voiceOn, setVoiceOn] = useState(false);
        const [musicOn, setMusicOn] = useState(false);
        const [rated, setRated] = useState(false);
        const [completed, setCompleted] = useState(false);
        const [currentExercise, setCurrentExercise] = useState(program[0]);

        const lastSpokenId = useRef(null);
        const sessionCueIndex = useRef({});  // remembers which cue we used this session

        const toggleVoice = () => {
            const next = !voiceOn;
            if (!next) window.speechSynthesis.cancel();
            setVoiceOn(next);
        };

        useEffect(() => {
            if (!musicOn) return;
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const master = ctx.createGain(); master.gain.value = 0.05; master.connect(ctx.destination);
            const osc432 = ctx.createOscillator(); osc432.type = 'sine'; osc432.frequency.value = 432;
            const osc528 = ctx.createOscillator(); osc528.type = 'triangle'; osc528.frequency.value = 528;
            const g = ctx.createGain(); g.gain.value = 0.26;
            const f = ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 820;
            osc432.connect(master);
            osc528.connect(g).connect(f).connect(master);
            osc432.start(); osc528.start();
            return () => { osc432.stop(); osc528.stop(); ctx.close(); };
        }, [musicOn]);

        // --- THE NEW VOICE LOGIC ---
        useEffect(() => {
            if (!voiceOn || !currentExercise || currentExercise.id === lastSpokenId.current) return;
            lastSpokenId.current = currentExercise.id;

            window.speechSynthesis.cancel();

            const voices = window.speechSynthesis.getVoices();
            // Prioritize deep/authoritative voices
            const best = voices.find(v => 
                /Daniel|Alex|Fred|Google.*male|Microsoft.*David/i.test(v.name)
            ) || voices.find(v => v.lang.includes('en')) || voices[0];

            const speak = (text) => {
                const u = new SpeechSynthesisUtterance(text);
                u.voice = best;
                u.rate = 0.95; // Slightly slower for clarity
                u.pitch = 0.9; // Slightly deeper for authority
                u.volume = 1.0;
                window.speechSynthesis.speak(u);
            };

            // *** THE UPGRADED DATABASE ***
            const masterCoach = {
                // --- POSTURE & NECK ---
                head_loading: [
                    "Lengthen the spine. Imagine the ball is floating, and you are reaching up to keep contact.",
                    "Chin tucked. Don't let the ribs flare. Breathe into the back of your neck. The deeper you breathe, the more you activate your core",
                    "Axial decompression. Feel the multifidus muscles waking up along your spine."
                ],
                head_loading_march: [
                    "Maintain the column. Head over hips over heels. No wobble.",
                    "As you lift the knee, drive the crown of your head higher.",
                    "Stabilize. The weight is teaching your spine how to resist gravity."
                ],
                
                // --- FEET & GAIT ---
                plantar_release: [
                    "Find the trigger point near the heel. Apply pressure and breathe.",
                    "Your foot is a sensory organ. Wake it up. Roll the inner arch.",
                    "Melt the fascia. When this releases, your hamstring and glute will fire instantly."
                ],
                towel_curl: [
                    "Spread the toes wide, then grip. Dominate the floor.",
                    "Don't just curl the toes, pull the arch up. Build the windlass mechanism.",
                    "This is intrinsic foot strength. It's the foundation of all athletic power."
                ],
                hyperarch: [
                    "Heels suspended. Do not let them touch the ground. You are a spring.",
                    "Pop. Pop. Pop. Minimal ground contact time. Stiffness is speed.",
                    "Load the Achilles. Recoil through the glute. Stay elastic."
                ],

                // --- KNEES & LEGS ---
                split_squat: [
                    "Full range. Let that front knee travel well past the toe. Restore the VMO.",
                    "Back leg straight. Squeeze the glute on the trailing leg to open the hip flexor.",
                    "Hamstring covers the calf at the bottom. Pressure proves the pipe."
                ],
                atg_split_squat: [
                    "Drive the knee forward. Keep the heel flat if you can, or elevate it.",
                    "This is structural integrity. You are bulletproofing the knee joint.",
                    "Long range strength. Fight for depth."
                ],

                // --- FASCIA & BOUNCE ---
                body_bounce: [
                    "Loose and rhythmic. Shake out the tension. Let the shoulders drop.",
                    "Shift the hips left and right. Feel the lateral fascial line engaging.",
                    "Lymphatic flush. Bounce on the balls of the feet. No muscle, just elasticity."
                ],
                body_wave: [
                    "Initiate from the tailbone. Ripple up through the spine.",
                    "Segmental motion. Vertebra by vertebra. Unlock the thoracic cage.",
                    "Flow like water. Remove the rigid blocks in your back."
                ],

                // --- ROTATION & CORE ---
                trunk_twist: [
                    "Hips and thoracic spine move together. Protect the lumbar.",
                    "Let the arms swing dead weight. Centrifugal force drives the blood flow.",
                    "Spiral line activation. Wring out the tension in the obliques."
                ],
                pallof: [
                    "Resist rotation. Shoulders down. Ribs locked to pelvis.",
                    "Anti-rotation is the prerequisite for power. Do not let the band win.",
                    "Breathe behind the shield. Brace the core, but keep breathing."
                ],
                landmine_rotation: [
                    "Pivot the foot! All power comes from the hip drive.",
                    "Arms stay straight. The bar moves because your hips rotate.",
                    "Transfer force from the ground, through the core, into the bar."
                ],
                band_twist: [
                    "Explosive hips. Snap the rotation. Control the return.",
                    "Load the posterior oblique sling. Lat to opposite glute.",
                    "Power comes from the coil. Twist and drive."
                ],
                coiling: [
                    "Side bend and rotate. Head over the load-bearing foot.",
                    "Load the spring. Feel the tension wrap around your torso.",
                    "The Royal Coil. Spiraling energy through the core. Maximize torsion."
                ],

                // --- SHOULDERS & ARMS ---
                arm_raise: [
                    "Thumbs up, ribs down. Do not arch your back to get the arms up.",
                    "True shoulder flexion. Reach for the ceiling, create space in the joint.",
                    "Open the deep front arm line. Breathe into the armpits."
                ],
                alt_arm_raise: [
                    "Contralateral rhythm. This is the gait cycle. Left arm, right leg.",
                    "Reach high. Reciprocate. One side lengthens, the other shortens.",
                    "Sync with your breath. Restore the cross-crawl pattern."
                ],
                chest_opener: [
                    "Dynamic opening. Squeeze the shoulder blades together at the back.",
                    "Open the front line. Undo the sitting posture.",
                    "Expand the ribcage. Big inhale as you open."
                ],
                trap_release: [
                    "Lean into the wall. Find the knot in the upper trap.",
                    "Pin the tissue, then move the arm. Floss the nerve.",
                    "Drop the shoulder. Stop wearing your shoulders as earrings."
                ],
                standing_pull: [
                    "Retract the scapula first. Pull with the back, not the arms.",
                    "Squeeze the mid-back. Lower trapezius activation.",
                    "Postural reset. Pull the shoulders back and down."
                ],
                contra_pull: [
                    "Step back and pull. Connect the right hand to the left foot.",
                    "Feel the X pattern across your back. That is the posterior oblique sling.",
                    "Tension through the torso. Do not let the spine twist."
                ],

                // --- POWER & INTEGRATION ---
                med_ball_power: [
                    "Reach high, slam hard! Use your whole bodyweight.",
                    "Flex at the hips. Drive the ball through the floor.",
                    "Explosive flexion. Turn potential energy into kinetic power."
                ],
                spinal_wave: [
                    "Roll down, chin to chest. Roll up, stacking the spine.",
                    "Articulate every joint. If a section feels stuck, spend time there.",
                    "Hydrate the discs. Movement is the pump."
                ],
                diaphragm_breath: [
                    "Breathe into the belly, not the chest. 360 degree expansion.",
                    "Intra-abdominal pressure. This is your internal weight belt.",
                    "Calm the nervous system. Slow, nasal inhale. Long exhale."
                ],
                inversion_hang: [
                    "Let gravity do the work. create space between the vertebrae.",
                    "Relax the lower back. Let the hips heavy.",
                    "Decompression. Undo the compressive forces of the day."
                ]
            };

            const cues = masterCoach[currentExercise.id] || [
                "Focus on quality movement.",
                "Control the range of motion.",
                "Breathe rhythmically."
            ];
            
            // Cycle through cues based on session history
            const index = (sessionCueIndex.current[currentExercise.id] || 0) % cues.length;
            sessionCueIndex.current[currentExercise.id] = index + 1;
            const line = cues[index];

            if (step === 0) {
                speak("Beginning Protocol. Let's go.");
                setTimeout(() => speak(line), 2500);
            } else {
                speak(line);
            }

        }, [voiceOn, currentExercise, step]);

        useEffect(() => { lastSpokenId.current = null; sessionCueIndex.current = {}; }, [step]);

        // Standard logic
        useEffect(() => {
            setCurrentExercise(program[step]);
            setRated(false);
            if (program[step]) setTimeLeft(program[step].duration);
            setPlaying(true);
        }, [step, program]);

        useEffect(() => {
            let i;
            if (playing && timeLeft > 0 && !completed)
                i = setInterval(() => setTimeLeft(t => t - 1), 1000);
            else if (timeLeft === 0) setPlaying(false);
            return () => clearInterval(i);
        }, [playing, timeLeft, completed]);

        const changeLevel = (dir) => {
            const idx = currentExercise.currentLevelIdx + dir;
            if (idx >= 0 && idx < currentExercise.allLevels.length) {
                setCurrentExercise({ ...currentExercise, ...currentExercise.allLevels[idx], currentLevelIdx: idx });
            }
        };

        const submitFeedback = (rating) => {
            onFeedback(currentExercise.id, currentExercise.currentLevelIdx, rating);
            setRated(true);
            setTimeout(() => {
                if (step < program.length - 1) setStep(s => s + 1);
                else { setCompleted(true); setPlaying(false); }
            }, 900);
        };

        const openVideo = () => {
            const q = currentExercise.videoSearch?.startsWith('http')
                ? currentExercise.videoSearch
                : `https://www.youtube.com/results?search_query=${encodeURIComponent(currentExercise.videoSearch || currentExercise.name)}`;
            window.open(q, '_blank');
        };

        if (completed) {
            return (
                <div className="fixed inset-0 bg-black/95 z-50 flex items-center justify-center p-4 backdrop-blur-md no-print animate-popIn">
                    <div className="bg-slate-900 w-full max-w-lg rounded-2xl border border-slate-700 shadow-2xl p-8 flex flex-col items-center text-center">
                        <div className="w-20 h-20 bg-emerald-500/20 rounded-full flex items-center justify-center mb-6">
                            <svg className="w-10 h-10 text-emerald-400" fill="none" stroke="currentColor" strokeWidth="3" viewBox="0 0 24 24"><path d="M20 6 9 17l-5-5"/></svg>
                        </div>
                        <h2 className="text-3xl font-black text-white mb-2">SESSION COMPLETE</h2>
                        <p className="text-slate-400 mb-8">Your body just changed forever.</p>
                        <button onClick={onClose} className="btn-primary w-full">RETURN</button>
                    </div>
                </div>
            );
        }

        return (
            <div className="fixed inset-0 bg-black/95 z-50 flex items-center justify-center p-4 backdrop-blur-md no-print">
                <div className="bg-slate-900 w-full max-w-6xl h-[90vh] rounded-2xl border border-slate-700 shadow-2xl flex flex-col md:flex-row overflow-hidden">
                    {/* Canvas */}
                    <div className="w-full md:w-2/3 bg-black flex flex-col relative border-r border-slate-800">
                        <div className="absolute top-4 left-4 z-10 pointer-events-none">
<span className="text-[10px] font-bold px-2 py-1 rounded border bg-slate-800 text-white border-slate-600">
    {currentExercise.baseTitle ? `FLOW STEP ${currentExercise.currentLevelIdx + 1}` : `LEVEL ${currentExercise.currentLevelIdx + 1}`}
</span>                        </div>
                        <div className="absolute top-4 right-4 z-10 flex gap-2 pointer-events-auto">
                            <button onClick={toggleVoice} className={`px-4 py-1.5 text-[10px] font-bold rounded flex items-center gap-2 shadow-lg transition-all ${voiceOn ? 'bg-cyan-600 text-white' : 'bg-slate-800 text-slate-400 border border-slate-600'}`}>
                                <Icons.Speaker/> COACH {voiceOn ? 'ON' : 'OFF'}
                            </button>
                            <button onClick={() => setMusicOn(m => !m)} className={`px-4 py-1.5 text-[10px] font-bold rounded flex items-center gap-2 shadow-lg transition-all ${musicOn ? 'bg-green-600 text-white' : 'bg-slate-800 text-slate-400 border border-slate-600'}`}>
                                <Icons.Music/> 432·528Hz
                            </button>
                            <button onClick={openVideo} className="px-3 py-1 bg-red-600 hover:bg-red-500 text-white text-[10px] font-bold rounded flex items-center gap-2 shadow-lg shadow-red-900/50 transition-all">
                                <Icons.Video/> TUTORIAL
                            </button>
                        </div>
                        <div className="flex-1 relative">
                            <KineticCanvas type={currentExercise.demoType} playing={playing} />
                            <div className="absolute bottom-8 left-1/2 -translate-x-1/2 text-5xl font-black text-white font-mono pointer-events-none">
                                {Math.floor(timeLeft/60)}:{(timeLeft%60).toString().padStart(2,'0')}
                            </div>
                        </div>
                        <div className="h-16 bg-slate-950 border-t border-slate-800 flex items-center px-6 justify-between">
                            <button onClick={() => setPlaying(p => !p)} className="text-white hover:text-cyan-400">
                                {playing ? <Icons.Pause/> : <Icons.Play/>}
                            </button>
                            <div className="flex gap-2">
                                <button onClick={() => setStep(Math.max(0, step - 1))} disabled={step === 0} className="btn-secondary">PREV</button>
                                <button onClick={() => setStep(Math.min(program.length - 1, step + 1))} disabled={step === program.length - 1} className="btn-primary">NEXT</button>
                            </div>
                        </div>
                    </div>

                    {/* RIGHT PANEL */}
                    <div className="w-full md:w-1/3 bg-slate-950 flex flex-col p-6 overflow-y-auto">
                        <div className="flex justify-between items-center mb-6"><h2 className="text-lg font-bold text-white flex gap-2"><Icons.List/> Protocol V84.0</h2><button onClick={onClose} className="text-slate-400 hover:text-white"><Icons.Close/></button></div>
                        <div>
                            <div className="flex justify-between items-start mb-1">
<h3 className="text-xl font-black text-white mb-2">
    {currentExercise.baseTitle ? currentExercise.baseTitle : currentExercise.name}
</h3>
<p className="text-sm text-cyan-400 mb-4">
    {currentExercise.baseTitle && `Step ${step + 1} of ${program.length}`}
</p>                            </div>
                            <div className="flex items-center gap-2 mb-4">
                                <button onClick={() => changeLevel(-1)} disabled={currentExercise.currentLevelIdx === 0} className="text-[10px] bg-slate-800 hover:bg-slate-700 disabled:opacity-30 px-2 py-1 rounded border border-slate-700 text-slate-300 flex items-center gap-1"><Icons.ArrowDown/> REGRESS</button>
                                <div className="flex gap-1">
                                    {currentExercise.allLevels.map((_, idx) => (
                                        <div key={idx} className={`w-2 h-2 rounded-full ${idx === currentExercise.currentLevelIdx ? 'bg-cyan-400' : 'bg-slate-800'}`}></div>
                                    ))}
                                </div>
                                <button onClick={() => changeLevel(1)} disabled={currentExercise.currentLevelIdx === currentExercise.allLevels.length - 1} className="text-[10px] bg-slate-800 hover:bg-slate-700 disabled:opacity-30 px-2 py-1 rounded border border-slate-700 text-slate-300 flex items-center gap-1">PROGRESS <Icons.ArrowUp/></button>
                            </div>
                            <div className="flex flex-wrap gap-2 mb-4">
                                <span className="text-xs bg-slate-800 px-2 py-1 rounded text-cyan-400 border border-slate-700">{currentExercise.duration}s</span>
                                <span className="text-xs bg-emerald-900/30 px-2 py-1 rounded text-emerald-400 border border-emerald-900/50">{currentExercise.reason}</span>
                            </div>
                            <p className="text-sm text-slate-400 leading-relaxed mb-4">{currentExercise.desc}</p>
                            <h4 className="text-xs font-bold text-slate-500 uppercase mb-2">Technique</h4>
                            <ul className="space-y-2 mb-6">{currentExercise.steps.map((s,i)=><li key={i} className="text-sm text-slate-300 flex gap-2"><span className="text-cyan-500 font-bold">{i+1}.</span>{s}</li>)}</ul>
                            <div className="bg-slate-900 border border-slate-800 p-4 rounded-xl mb-4">
                                <h4 className="text-[10px] font-bold text-slate-500 uppercase mb-3 text-center">How was this set?</h4>
                                {rated ? (
                                    <div className="text-center text-xs text-emerald-400 font-bold py-2 animate-pulse">Feedback Saved</div>
                                ) : (
                                    <div className="flex gap-2">
                                        <button onClick={() => submitFeedback('easy')} className="flex-1 py-2 rounded bg-slate-800 hover:bg-emerald-900/30 border border-slate-700 hover:border-emerald-500/50 text-[10px] font-bold text-slate-300 hover:text-emerald-400 transition-all">TOO EASY</button>
                                        <button onClick={() => submitFeedback('good')} className="flex-1 py-2 rounded bg-slate-800 hover:bg-blue-900/30 border border-slate-700 hover:border-blue-500/50 text-[10px] font-bold text-slate-300 hover:text-blue-400 transition-all">JUST RIGHT</button>
                                        <button onClick={() => submitFeedback('hard')} className="flex-1 py-2 rounded bg-slate-800 hover:bg-red-900/30 border border-slate-700 hover:border-red-500/50 text-[10px] font-bold text-slate-300 hover:text-red-400 transition-all">TOO HARD</button>
                                    </div>
                                )}
                            </div>
                        </div>
                        <div className="mt-auto pt-6 border-t border-slate-800">
                            <h4 className="text-xs font-bold text-slate-500 uppercase mb-3">Session Roadmap</h4>
                            <div className="space-y-2">{program.map((p, idx) => <div key={idx} onClick={() => setStep(idx)} className={`text-xs p-2 rounded cursor-pointer flex justify-between ${idx === step ? 'bg-cyan-900/20 text-cyan-400' : 'text-slate-500'}`}><span>{idx + 1}. {p.baseTitle}</span>
                            {p.reason === "Universal Primer" && <span className="text-[9px] font-bold text-emerald-400 bg-emerald-900/30 px-1 rounded ml-2">UNIVERSAL</span>}
                            {p.reason.includes("Fixes Knee") && <span className="text-[9px] font-bold text-red-400 bg-red-900/30 px-1 rounded ml-2">KNEE RELIEF</span>}
                            {p.reason.includes("Spinal") && <span className="text-[9px] font-bold text-yellow-400 bg-yellow-900/30 px-1 rounded ml-2">BACK RELIEF</span>}
                            <span className="opacity-50 ml-auto">LVL {p.currentLevelIdx+1}</span></div>)}</div>
                        </div>
                    </div>
                </div>
            </div>
        );
    };
const TrendGraph = ({ history }) => {
    if(history.length < 2) return <div className="mb-6 p-4 bg-slate-900/30 rounded text-center text-xs text-slate-500">Scan again to see trend</div>;
    
    // FIX 1: Limit to strictly the last 20 items to prevent overcrowding
    const recentHistory = history.slice(0, 20).reverse(); // Reverse so oldest is left, newest is right
    const scores = recentHistory.map(h => h.score);
    
    const h = 50, w = 280;
    // FIX 2: Ensure X coordinates are distributed evenly across the width (0 to w)
    const points = scores.map((s, i) => {
        const x = (i / (scores.length - 1)) * w;
        const y = h - (s / 100) * h;
        return `${x},${y}`;
    }).join(' ');

    return (
        <div className="mb-6">
            <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">Recovery Trend (Last {scores.length})</div>
            <div className="h-[50px] w-full bg-slate-900/30 rounded relative overflow-hidden">
                <svg className="w-full h-full" viewBox={`0 0 ${w} ${h}`} preserveAspectRatio="none">
                    {/* The line connecting the dots */}
                    <polyline points={points} fill="none" stroke="#22d3ee" strokeWidth="2" vectorEffect="non-scaling-stroke" />
                    {/* The dots themselves */}
                    {scores.map((s, i) => (
                        <circle key={i} cx={(i / (scores.length - 1)) * w} cy={h - (s / 100) * h} r="3" fill="#0f172a" stroke="#22d3ee" strokeWidth="2" />
                    ))}
                </svg>
            </div>
            {/* Recent Scans list code remains here... */}
        </div>
    );
};

    const ReaderMode = ({ item, onClose }) => (
        <div className="fixed inset-0 bg-slate-950 z-50 overflow-y-auto no-print flex justify-center">
            <div className="w-full max-w-3xl bg-slate-900 min-h-screen border-x border-slate-800 shadow-2xl relative">
                <button onClick={onClose} className="fixed top-6 right-6 p-3 bg-slate-800 hover:bg-slate-700 rounded-full text-white shadow-lg z-50"><Icons.Close/></button>
                <div className={`h-64 w-full bg-gradient-to-br ${item.color} flex items-end p-8`}>
                    <div>
                        <div className="text-xs font-bold text-white/80 uppercase tracking-widest mb-2">MASTERCLASS</div>
                        <h1 className="text-4xl font-black text-white tracking-tighter mb-2">{item.title}</h1>
                        <p className="text-lg text-white/90 font-medium">{item.subtitle}</p>
                    </div>
                </div>
                <div className="p-8 md:p-12 space-y-8">
                    <div className="flex gap-4 border-b border-slate-800 pb-8">
                        <div className="w-12 h-12 rounded-full bg-slate-800 flex items-center justify-center text-xl"></div>
                        <div>
                            <div className="text-sm font-bold text-white">Curated by {item.author}</div>
                            <div className="text-xs text-slate-500">Verified Methodology</div>
                        </div>
                    </div>
                    <div className="prose prose-invert max-w-none">
                        <p className="text-lg text-slate-300 leading-relaxed font-light border-l-4 border-cyan-500 pl-4 mb-8">{item.desc}</p>
                        <h3 className="text-xl font-bold text-white mb-4">Core Principles</h3>
                        {item.sections && item.sections.map((sec, i) => (
                            <div key={i} className="mb-8">
                                <h4 className="text-lg font-bold text-cyan-400 mb-2">{sec.head}</h4>
                                <p className="text-slate-300 leading-relaxed">{sec.body}</p>
                            </div>
                        ))}
                        <h3 className="text-xl font-bold text-white mb-4">Key Terminology</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            {item.key_terms && item.key_terms.map((term, i) => (
                                <div key={i} className="bg-slate-950 p-4 rounded border border-slate-800 text-sm text-cyan-400 font-mono">{term}</div>
                            ))}
                        </div>
                    </div>
                    <div className="pt-12 text-center">
                        <button onClick={onClose} className="btn-primary w-auto inline-flex">RETURN TO DASHBOARD</button>
                    </div>
                </div>
            </div>
        </div>
    );

    const KnowledgeBase = ({ onOpen }) => (
        <div className="p-8 space-y-6 overflow-y-auto h-full pb-24">
            <div className="border-b border-slate-800 pb-4 mb-6">
                <h2 className="text-2xl font-black text-white tracking-tighter mb-2">DECENTRALIZED <span className="text-cyan-500">MOVEMENT</span></h2>
                <p className="text-xs text-slate-500">Mastering Movement.</p>
            </div>
            <div className="grid grid-cols-1 gap-4">
                {ACADEMY.map((item, i) => (
                    <div key={i} onClick={() => onOpen(item)} className="bg-slate-900/50 border border-slate-700 rounded-xl p-6 hover:border-cyan-500/50 transition-all group cursor-pointer hover:bg-slate-800/50">
                        <div className={`h-1 w-10 rounded-full bg-gradient-to-r ${item.color} mb-4`}></div>
                        <h3 className="text-lg font-bold text-white mb-1 group-hover:text-cyan-400 transition-colors">{item.title}</h3>
                        <div className="text-xs font-bold text-slate-400 uppercase mb-3">{item.subtitle}</div>
                        <p className="text-sm text-slate-400 leading-relaxed line-clamp-2">{item.desc}</p>
                        <div className="mt-4 text-xs font-bold text-cyan-600 flex items-center gap-1">READ MASTERCLASS <Icons.Video/></div>
                    </div>
                ))}
            </div>
        </div>
    );

    // --- NEW: Goal Setter Modal ---
    const GoalSetter = ({ currentGoal, onSave, onClose }) => {
        const [target, setTarget] = useState(currentGoal.target || 80);
        const [duration, setDuration] = useState(currentGoal.duration || 30);
        return (
            <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
                <div className="bg-slate-900 w-full max-w-md rounded-xl border border-slate-700 p-6">
                    <h3 className="text-lg font-bold text-white mb-4">Set Your Goal</h3>
                    <div className="space-y-4">
                        <div>
                            <label className="text-xs text-slate-400 mb-1 block">Target Score (%)</label>
                            <input type="range" min="50" max="100" value={target} onChange={(e) => setTarget(e.target.value)} className="w-full" />
                            <div className="text-sm text-white">{target}%</div>
                        </div>
                        <div>
                            <label className="text-xs text-slate-400 mb-1 block">Duration (Days)</label>
                            <input type="number" min="7" max="90" value={duration} onChange={(e) => setDuration(e.target.value)} className="w-full bg-slate-800 border border-slate-700 rounded px-3 py-2 text-white text-sm" />
                        </div>
                        <div className="flex gap-2 pt-4">
                            <button onClick={onClose} className="flex-1 py-2 bg-slate-800 hover:bg-slate-700 rounded text-white text-sm">Cancel</button>
                            <button onClick={() => onSave({ target, duration })} className="flex-1 py-2 bg-cyan-600 hover:bg-cyan-500 rounded text-white text-sm font-bold">Save Goal</button>
                        </div>
                    </div>
                </div>
            </div>
        );
    };

    // --- NEW: Share Report Component ---
    const ShareReport = ({ audit, onClose }) => {
        const shareData = audit ? `Bio-Metric Pro Score: ${audit.score}% | Date: ${audit.date} | Share your progress!` : '';
        const handleShare = async () => {
            if (navigator.share) {
                await navigator.share({ title: 'Bio-Metric Progress', text: shareData });
            } else {
                navigator.clipboard.writeText(shareData);
                alert('Copied to clipboard!');
            }
            onClose();
        };
        return (
            <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
                <div className="bg-slate-900 w-full max-w-md rounded-xl border border-slate-700 p-6 text-center">
                    <h3 className="text-lg font-bold text-white mb-4">Share Your Report</h3>
                    <p className="text-sm text-slate-400 mb-4">{shareData}</p>
                    <button onClick={handleShare} className="w-full py-3 bg-cyan-600 hover:bg-cyan-500 rounded text-white font-bold mb-2 flex items-center justify-center gap-2"><Icons.Share /> Share Now</button>
                    <button onClick={onClose} className="w-full py-2 text-slate-400 hover:text-white text-sm">Cancel</button>
                </div>
            </div>
        );
    };
// --- FIXED CAMERA COMPONENT (Direct Gesture Compliant) ---
const CameraCapture = ({ onCapture, onClose }) => {
    const videoRef = useRef(null);
    const [timer, setTimer] = useState(null);
    const [stream, setStream] = useState(null);

    // Start camera IMMEDIATELY on mount (triggered directly by user click)
    useEffect(() => {
        let activeStream = null;

        const startCamera = async () => {
            try {
                const s = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user' }  // Front camera on mobile
                });
                activeStream = s;
                setStream(s);
                if (videoRef.current) {
                    videoRef.current.srcObject = s;
                }
            } catch (err) {
                console.error("Camera access failed:", err);
                alert("Camera access denied or unavailable. Check permissions and try again.");
                onClose();
            }
        };

        startCamera();

        // Cleanup: Stop tracks when component unmounts
        return () => {
            if (activeStream) {
                activeStream.getTracks().forEach(track => track.stop());
            }
        };
    }, [onClose]);  // Only run once on mount

    const triggerCapture = () => {
        setTimer(3);
    };

    // Timer countdown and capture
    useEffect(() => {
        if (timer === null || timer === 0) return;

        if (timer > 0) {
            const id = setTimeout(() => setTimer(timer - 1), 1000);
            return () => clearTimeout(id);
        } else {
            // Timer hit 0 → capture photo
            const canvas = document.createElement('canvas');
            canvas.width = videoRef.current.videoWidth;
            canvas.height = videoRef.current.videoHeight;
            const ctx = canvas.getContext('2d');
            
            // Flip horizontally to correct mirror effect
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(videoRef.current, 0, 0);

            onCapture(canvas.toDataURL('image/jpeg', 0.9));
            
            // Stop camera after capture
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        }
    }, [timer, onCapture, stream]);

    return (
        <div className="fixed inset-0 bg-black/95 z-[60] flex flex-col items-center justify-center p-4 animate-popIn">
            <div className="relative w-full max-w-lg bg-slate-900 border border-slate-700 rounded-2xl overflow-hidden shadow-2xl">
                <video 
                    ref={videoRef} 
                    autoPlay 
                    playsInline 
                    muted
                    className="w-full bg-black transform scale-x-[-1]" 
                />
                {timer > 0 && (
                    <div className="absolute inset-0 flex items-center justify-center bg-black/40 text-9xl font-black text-white animate-ping backdrop-blur-sm">
                        {timer}
                    </div>
                )}
                <div className="absolute bottom-6 left-0 right-0 flex justify-center gap-4">
                    <button 
                        onClick={onClose} 
                        className="px-6 py-2 bg-slate-800 text-slate-300 rounded-full font-bold border border-slate-600 hover:bg-slate-700 transition-all"
                    >
                        CANCEL
                    </button>
                    <button 
                        onClick={triggerCapture} 
                        disabled={timer !== null}
                        className="px-6 py-2 bg-cyan-600 text-white rounded-full font-bold shadow-lg flex items-center gap-2 hover:bg-cyan-500 transition-all disabled:opacity-50"
                    >
                        <Icons.Camera/> {timer !== null ? 'CAPTURING...' : 'CAPTURE (3s)'}
                    </button>
                </div>
            </div>
        </div>
    );
};
    const App = () => {
        const [uploads, setUploads] = useState({ front: null, side: null, back: null });
	const [cameraActive, setCameraActive] = useState(null);
        const [system, setSystem] = useState({ detector: null });
        const [status, setStatus] = useState({ logs: ["System Initializing..."], analyzing: false });
        const [audit, setAudit] = useState(null);
        const [activeProgram, setActiveProgram] = useState(null);
        const [history, setHistory] = useState([]);
        const [symptoms, setSymptoms] = useState([]); 
	const [userPrefs, setUserPrefs] = useState({ lowImpact: false, noJumps: false, noEquipment: false });
        const [tab, setTab] = useState('dashboard');
        const [showReader, setShowReader] = useState(null);
        
        // New Panel State
        const [rightPanelTab, setRightPanelTab] = useState('data'); // 'data' or 'twin'
        const [chatHistory, setChatHistory] = useState([]);
        
        // DAILY HABIT STATE
        const [dailyRoutine, setDailyRoutine] = useState([]);
        const [achievements, setAchievements] = useState([
            { id: 1, name: "First Step", desc: "Complete your first scan", unlocked: false, icon: <Icons.Check/> },
            { id: 2, name: "Consistency King", desc: "Scan 3 days in a row", unlocked: false, icon: <Icons.History/> },
            { id: 3, name: "Elite Structure", desc: "Achieve a Score > 80", unlocked: false, icon: <Icons.Award/> }
        ]);

        // Exercise History to ensure variety
        const [exerciseHistory, setExerciseHistory] = useState({}); 
        
        // Equipment Filter
        const [useEquipment, setUseEquipment] = useState(true);

        // NEW: Retention States
        const [streakDays, setStreakDays] = useState(0);
        const [currentGoal, setCurrentGoal] = useState({ target: 80, duration: 30, startDate: new Date().toDateString() });
        const [showGoalSetter, setShowGoalSetter] = useState(false);
        const [showShare, setShowShare] = useState(false);
	const [showProtocolButton, setShowProtocolButton] = useState(false);
	const [currentTheme, setCurrentTheme] = useState('power');  // Weekly theme: power, recovery, mobility
	const debouncedRunAnalysis = React.useCallback(() => {
            if (status.analyzing) return; // Ignore duplicates
            requestAnimationFrame(runAnalysis); // Queue after UI paints (smooth!)
        }, [status.analyzing]);
        const uploadRefs = { front: useRef(null), side: useRef(null), back: useRef(null) };

        const addLog = (msg) => setStatus(prev => ({ ...prev, logs: [`> ${msg}`, ...prev.logs].slice(0, 4) }));

        // NEW: Handle Exercise Feedback (ENHANCED for goodStreaks)
        const handleFeedback = (exerciseId, levelIdx, rating) => {
            const newHistory = { ...exerciseHistory };
            const existing = newHistory[exerciseId] || {};
            let goodStreaks = existing.goodStreaks || 0;
            if (rating === 'good') {
                goodStreaks = Math.min(3, goodStreaks + 1);
            } else {
                goodStreaks = 0;
            }
            newHistory[exerciseId] = {
                ...existing,
                lastUsed: new Date().toDateString(),
                lastLevel: levelIdx,
                lastRating: rating,
                goodStreaks
            };
            setExerciseHistory(newHistory);
            // Visual feedback log
            const rateMsg = rating === 'easy' ? "Marked Easy (Progressing next time)" : rating === 'hard' ? "Marked Hard (Regressing next time)" : "Marked Good (Maintaining)";
            addLog(rateMsg);
        };

        // NEW HELPER: Quick trend delta (improvement over last 3 sessions)
        const getTrendDelta = (history, bodyPart) => {
            if (history.length < 2) return 0;
            const recent = history.slice(0, 3).map(h => h[bodyPart].val).reverse(); // Last 3 vals (lower val = worse)
            return (recent[0] - recent[recent.length - 1]) / recent.length; // Positive = improving
        };

        useEffect(() => {
    const init = async () => {
        addLog("Warming AI Engine..."); // User sees this immediately

        // Step 1: Load TF.js if missing (async, non-blocking)
        if (!window.tf) {
            const tfScript = document.createElement('script');
            tfScript.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js';
            tfScript.async = true;
            document.head.appendChild(tfScript);
            await new Promise(resolve => { tfScript.onload = resolve; });
            addLog("TensorFlow Loaded");
        }

        // Step 2: Load Pose Detection if missing
        if (!window.poseDetection) {
            const pdScript = document.createElement('script');
            pdScript.src = 'https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3';
            pdScript.async = true;
            document.head.appendChild(pdScript);
            await new Promise(resolve => { pdScript.onload = resolve; });
            addLog("Pose Detection Loaded");
        }

 // --- UPGRADE TO MEDIAPIPE POSE (More Accurate in 2025) ---
if (!window.mediaPipePose) {
    addLog("Loading MediaPipe Pose (higher precision)...");
    const mpScript = document.createElement('script');
    mpScript.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1677925678/pose.js';
    mpScript.crossOrigin = 'anonymous';
    document.head.appendChild(mpScript);
    await new Promise(r => mpScript.onload = r);

    const mpVisionScript = document.createElement('script');
    mpVisionScript.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js';
    mpVisionScript.crossOrigin = 'anonymous';
    document.head.appendChild(mpVisionScript);
    await new Promise(r => mpVisionScript.onload = r);
}

// Create MediaPipe Pose detector
const vision = window.vision;
const poseLandmarker = await vision.PoseLandmarker.createFromOptions({
    baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/1/pose_landmarker_heavy.task',
        delegate: "GPU"
    },
    runningMode: "IMAGE",
    numPoses: 1
});

net = {
    estimatePoses: async (image) => {
        const results = await poseLandmarker.detect(image);
        if (results.landmarks.length === 0) return [];
        // Convert to MoveNet-like format for compatibility
        const keypoints = results.landmarks[0].map((lm, i) => ({
            x: lm.x,
            y: lm.y,
            score: lm.visibility || 1.0,
            name: ['nose','left_eye_inner','left_eye','left_eye_outer','right_eye_inner','right_eye','right_eye_outer','left_ear','right_ear','mouth_left','mouth_right','left_shoulder','right_shoulder','left_elbow','right_elbow','left_wrist','right_wrist','left_pinky','right_pinky','left_index','right_index','left_thumb','right_thumb','right_thumb','left_hip','right_hip','left_knee','right_knee','left_ankle','right_ankle','left_heel','right_heel','left_foot_index','right_foot_index'][i] || 'unknown'
        }));
        return [{ keypoints }];
    }
};

        // Rest of your existing init logic (localStorage, etc.)
        const saved = localStorage.getItem('biometric_data_v82'); 
        if(saved) {
            // ... (unchanged)
        } else {
            // ... (unchanged)
        }
    };
    init();
}, []);

        // NEW: Streak Calculation
        const calculateStreak = (hist) => {
            if (hist.length === 0) return;
            const dates = hist.map(h => new Date(h.date).toDateString()).sort();
            let streak = 0;
            const today = new Date().toDateString();
            if (dates[dates.length - 1] === today) streak = 1;
            for (let i = dates.length - 2; i >= 0; i--) {
                const prevDate = new Date(dates[i]);
                const nextDate = new Date(dates[i + 1]);
                if (nextDate - prevDate === 86400000) { // 24 hours
                    streak++;
                } else break;
            }
            setStreakDays(streak);
        };

        // NEW: Save Goal
        const saveGoal = (goal) => {
            setCurrentGoal(goal);
            localStorage.setItem('bio_goal', JSON.stringify(goal));
            setShowGoalSetter(false);
            addLog(`Goal Set: ${goal.target}% in ${goal.duration} days`);
        };

        useEffect(() => {
            if(chatHistory.length > 0) localStorage.setItem('bio_chat_memory', JSON.stringify(chatHistory));
        }, [chatHistory]);

        // Save exercise history whenever it changes
        useEffect(() => {
            if(Object.keys(exerciseHistory).length > 0) localStorage.setItem('bio_exercise_history', JSON.stringify(exerciseHistory));
        }, [exerciseHistory]);

        // NEW: Reset Streak (For Testing/Edge Cases)
        const resetStreak = () => setStreakDays(0);

        const updateBadges = (hist) => {
            setAchievements(prev => prev.map(badge => {
                if (badge.id === 1 && hist.length > 0) return { ...badge, unlocked: true };
                if (badge.id === 2 && hist.length >= 3) return { ...badge, unlocked: true }; 
                if (badge.id === 3 && hist.some(h => h.score > 80)) return { ...badge, unlocked: true };
                return { ...badge, unlocked: false }; 
            }));
        };

        const handleFile = (e, view) => {
            if(e.target.files[0]) {
                setUploads(prev => ({ ...prev, [view]: { url: URL.createObjectURL(e.target.files[0]), analyzed: false } }));
                addLog(`${view.toUpperCase()} View Loaded`);
            }
        };
        
        const toggleSymptom = (sym) => {
            setSymptoms(prev => prev.includes(sym) ? prev.filter(s => s !== sym) : [...prev, sym]);
        };
        
        const toggleDailyTask = (index) => {
            const newRoutine = [...dailyRoutine];
            newRoutine[index].completed = !newRoutine[index].completed;
            setDailyRoutine(newRoutine);
        };

    // REPLACED & UPGRADED AI COACH ENGINE (V84.0 – Decentralized Genius Core)
    const handleChat = (input) => {
        setChatHistory(prev => [...prev, {sender: 'user', text: input}]);
        const lower = input.toLowerCase();

        let response = "";

        // === MASTER-LEVEL KNOWLEDGE GRAPH (NO NAMES, PURE INSIGHTS) ===
        const knows = {
            "three planes" : "Power is not linear. True force generation requires mastery of all three planes simultaneously. Most training lives only in sagittal flexion/extension and ignores the frontal (side-to-side) and especially transverse (rotational) planes. The transverse plane is where athleticism lives — it’s the difference between moving like a robot and moving like a predator.",
            "rotation" : "Rotation is not created by the core — it is transferred through it. The core’s primary job is anti-rotation. Only when it can resist unwanted twist can it safely allow controlled rotation through the hips and thoracic spine. Forcing lumbar rotation is the fastest way to destroy a spine.",
            "coiling" : "Elite movers don’t brace rigidly — they coil. The torso side-bends and rotates opposite the pelvis, loading the fascial springs like a twisted rubber band. This is how explosive power is stored and released without conscious effort.",
            "head over foot" : "Your balance is dictated by one relationship only: the position of the head relative to the weight-bearing foot. When the head drifts outside this column, the glutes shut off and the lower back takes over. Aligning head directly over the loaded foot instantly reconnects the lat-glute sling across the torso.",
            "hyperarch" : "The foot is your battery. In elite locomotion the heel never fully collapses — it hovers in a state of constant tension (the hyperarch). This keeps the Achilles and plantar fascia loaded like a spring and sends a direct neural drive signal straight to the glute. Collapse the arch and you lose the entire posterior chain.",
            "vmo" : "The VMO isn’t built with leg extensions. It fires maximally when the knee travels far past the toes under load in deep flexion — exactly the position modern fitness demonized for decades. To awaken it you must progressively reintroduce the body to its end-range capacity.",
            "sling" : "You are not a stack of muscles — you are a series of crossed fascial slings. Posterior oblique (lat → opposite glute), anterior oblique (pec/oblique → opposite adductor), and deep longitudinal (glute → plantar fascia via peroneals). Pain is usually sling disconnection, not local muscle weakness.",
            "tensegrity" : "Compression destroys joints. The human frame is a tensegrity structure — it is meant to be held together by continuous tension, not stacked compression. Every movement should pull the skeleton apart at the joints, creating space. This is why elongation under load heals cartilage and reverses degeneration.",
            "breath" : "The diaphragm is the hydraulic pump of the entire fascial web. Shallow chest breathing disconnects the core from the pelvic floor and turns off the slings. True diaphragmatic breath on inhalation creates intra-abdominal pressure that supports spinal elongation and sling activation.",
            "gait" : "Walking is falling forward and catching yourself with elastic recoil — not pushing off with muscles. The opposite arm and leg must swing together (contralateral reciprocation) to load the spiral engine through the torso. Lock the ribs to the pelvis and you kill this torsion — and all power with it.",
            "windlass" : "The windlass mechanism is the foot’s natural shock absorber and propulsion system. When the big toe dorsiflexes, it tightens the plantar fascia like pulling a bowstring. Modern cushioned shoes have made this mechanism dormant in most humans.",
            "anti-rotation" : "You must earn the right to rotate. Anti-rotation precedes rotation. If you cannot resist external rotational forces, any attempt to produce rotation will leak through the lumbar spine and cause injury.",
            "decompression" : "Gravity is the enemy over decades. Every joint in the body needs regular decompression — traction, inversion, or elongation under load — to pump synovial fluid and prevent the slow crush of cartilage.",
            "elastic recoil" : "Muscles don’t create speed — fascia does. The fastest athletes in the world barely use muscular contraction. They load their tendons and fascia like springs and release. This is why stiffness (not flexibility) is the hallmark of elite performance."
        };

        if (lower.includes("explain my grade") || lower.includes("score")) {
            response = `Your overall integrity is ${audit?.score || '--'}%. But scores are symptoms. The real question is: which plane or sling is disconnected? Right now your limiting factor is ${audit ? Object.keys(audit).find(k => audit[k].grade === 'F' || audit[k].grade === 'D')?.toUpperCase() || 'unknown' : 'not scanned'}. That disconnection cascades through every movement you make. Fix the root and everything upstream heals.`;
        }
        else if (lower.includes("why") && lower.includes("head") && lower.includes("load")) {
            response = "Because the deep spinal stabilizers only fire reflexively under axial load. Conscious effort cannot activate them properly. Placing load directly on the cranium forces the multifidus and transverse abdominis to wake up instantly — realigning the entire column from C1 to sacrum without thinking.";
        }
        else if (lower.includes("knee") && lower.includes("pain")) {
            response = "Knee pain is rarely the knee. It’s almost always a collapsed arch or a dropped hip breaking the posterior oblique sling. When the glute can’t fire through the lat, the quadriceps (and patellar tendon) take over propulsion duty. Restore foot-glute continuity first — the knee usually resolves itself.";
        }
        else if (lower.includes("vmo")) {
            response = "The VMO only grows in the position everyone was told to avoid: deep knee flexion past the toes. It is the brake that keeps the kneecap tracking correctly. Train it there progressively and it becomes bulletproof. Anything else is cosmetic.";
        }
        else if (lower.includes("coil") || lower.includes("rotational") || lower.includes("twist")) {
            response = "Rigid bracing kills power. True rotational athletes move like a whip — the core coils in the opposite direction of the pelvis, loading the spiral line like a spring. This is why a golfer or thrower can generate massive torque with almost no visible muscle tension.";
        }
        else if (lower.includes("foot") || lower.includes("arch") || lower.includes("hyperarch") || lower.includes("heel")) {
            response = "Your foot is not a passive platform — it’s your primary elastic engine. In elite sprinting the heel never fully weight-bears. It stays suspended, keeping constant tension through the Achilles and plantar fascia into the glutes. Train barefoot, on forefoot, with rapid recoil — not slow grinding.";
        }
        else if (lower.includes("sling") || lower.includes("fascial") || lower.includes("chain") || lower.includes("x pattern")) {
            response = "You don’t have individual muscles — you have crossed fascial slings that work contralaterally. When one side steps forward, the opposite lat and glute fire together through the thoracolumbar fascia. Break that X and you get pain, leakage, and zero power.";
        }
        else if (lower.includes("breath") || lower.includes("diaphragm") || lower.includes("breathing")) {
            response = "The diaphragm descending on inhale creates 360° intra-abdominal pressure that elongates the spine and pre-tensions every sling. Chest breathing turns this pump off and collapses the entire system. Breathe into the pelvic floor and back body — not the chest.";
        }
        else if (lower.includes("routine") || lower.includes("plan") || lower.includes("optimize") || lower.includes("best") || lower.includes("program")) {
            response = "Your protocol has already been recalculated using spiral dynamics, sling integrity, and 3-plane scoring. It prioritizes anti-rotation before rotation, decompression before compression, and elastic recoil over muscular pushing. Trust the process — it’s built on principles, not trends.";
        }
        else {
            const insights = Object.values(knows);
            response = insights[Math.floor(Math.random() * insights.length)];
        }

        setTimeout(() => {
            setChatHistory(prev => [...prev, {sender: 'ai', text: response}]);
        }, 800);
    };
const drawSkeleton = (keypoints, view) => {
    const canvas = document.getElementById(`canvas-${view}`);
    if (!canvas || !uploadRefs[view].current) return;

    const img = uploadRefs[view].current;
    const container = canvas.parentElement;
    const contW = container.clientWidth;
    const contH = container.clientHeight;

    // High-res canvas
    const dpr = window.devicePixelRatio || 1;
    canvas.width = contW * dpr;
    canvas.height = contH * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);

    ctx.clearRect(0, 0, contW, contH);

    // Draw the original image with proper letterboxing (object-contain)
    const imgRatio = img.naturalWidth / img.naturalHeight;
    const contRatio = contW / contH;
    let drawW, drawH, offsetX = 0, offsetY = 0;
    if (imgRatio > contRatio) {
        drawH = contH;
        drawW = drawH * imgRatio;
        offsetX = (contW - drawW) / 2;
    } else {
        drawW = contW;
        drawH = drawW / imgRatio;
        offsetY = (contH - drawH) / 2;
    }
    ctx.drawImage(img, offsetX, offsetY, drawW, drawH);

    // THIS IS THE KEY FIX: keypoints.x and .y are 0-1 normalized
    // We scale them directly to the displayed image size (including offsets)
    const scaledKeypoints = keypoints.map(kp => ({
        x: kp.x * drawW + offsetX,
        y: kp.y * drawH + offsetY,
        score: kp.score
    }));

    // Draw skeleton lines
// Robust connections — works with MoveNet (17) and MediaPipe (33)
const connections = [
    [5,6], [5,11], [6,12], [11,12],           // torso
    [5,7], [7,9], [6,8], [8,10],              // arms
    [11,13], [13,15], [12,14], [14,16],       // legs
    [11,23], [12,24], [23,25], [24,26]         // extra lower body if available (MediaPipe)
].filter(pair => 
    pair[0] < keypoints.length && pair[1] < keypoints.length &&
    keypoints[pair[0]] && keypoints[pair[1]] &&
    keypoints[pair[0]].score > 0.2 && keypoints[pair[1]].score > 0.2
);    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    connections.forEach(([i, j]) => {
        const p1 = scaledKeypoints[i];
        const p2 = scaledKeypoints[j];
        if (!p1 || !p2) return;
        const avgScore = (p1.score + p2.score) / 2;
        if (avgScore > 0.2) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = avgScore > 0.4 ? '#22d3ee' : 'rgba(34,211,238,0.5)';
            ctx.lineWidth = avgScore > 0.4 ? 5 : 3;
            ctx.stroke();
        }
    });

    // Draw keypoints (cyan dots)
    scaledKeypoints.forEach(kp => {
        if (kp.score > 0.3) {
            ctx.beginPath();
            ctx.arc(kp.x, kp.y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = '#0f172a';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(kp.x, kp.y, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#22d3ee';
            ctx.fill();
        }
    });
};
// ... inside the App component return statement ...

<div className="upload-grid flex-1">
    {['front', 'side', 'back'].map(view => (
<div key={view} className={`upload-slot relative ${uploads[view] ? 'active' : ''} ${status.analyzing ? 'analyzing' : ''}`}>
            {uploads[view] ? (
                <div className="w-full h-full relative group" onClick={() => uploadRefs[view].current.click()}>
                    
                    {/* 2. FIX APPLIED HERE: Added 'object-contain' to canvas className */}
                    {/* This ensures the canvas respects aspect ratio and aligns with the image */}
                    
                    <img 
                        ref={el => { if(el) uploadRefs[view].current = el; }} 
                        src={uploads[view].url} 
                        className="opacity-0 absolute inset-0 w-full h-full object-contain" 
                        crossOrigin="anonymous" 
                        alt="analysis-source"
                    />
                    
                    {/* We hide the img (opacity-0) and let the canvas render everything to guarantee alignment */}
                    <canvas 
                        id={`canvas-${view}`} 
                        className="absolute inset-0 w-full h-full object-contain pointer-events-none"
                    />

                    <div className="absolute top-2 right-2 bg-emerald-500 text-black text-[10px] font-bold px-2 py-1 rounded flex items-center gap-1"><Icons.Check/> LOADED</div>
                    <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center text-xs font-bold uppercase tracking-widest">Click to Change</div>
                </div>
            ) : (
                // ... empty slot state ...
                <div className="flex flex-col items-center gap-3 opacity-60 hover:opacity-100 transition-opacity">
                     <div className="flex gap-4">
                        <button onClick={() => uploadRefs[view].current.click()} className="p-4 rounded-full bg-slate-800 text-cyan-400 hover:bg-slate-700 hover:scale-110 transition-all border border-slate-700 shadow-lg" title="Upload Photo"><Icons.Plus /></button>
                        <button onClick={() => setCameraActive(view)} className="p-4 rounded-full bg-slate-800 text-emerald-400 hover:bg-slate-700 hover:scale-110 transition-all border border-slate-700 shadow-lg" title="Use Camera"><Icons.Camera /></button>
                    </div>
                    <span className="text-xs font-bold tracking-widest uppercase text-slate-500">{view} VIEW</span>
                </div>
            )}
            <div className="scanner-line"></div>
            <input type="file" ref={uploadRefs[view]} className="hidden" accept="image/*" onChange={(e) => handleFile(e, view)} />
        </div>
    ))}
</div>

    const runAnalysis = async () => {
        // --- FIX 1: LOCAL VARIABLE LOGIC ---
        // We use a local variable 'net' to hold the detector immediately.
        // We do NOT wait for React's 'system.detector' state to update.
        let net = system.detector;

        if (!net) {
            addLog("Loading AI Engine (first time)...");
            
            // Load TensorFlow
            if (!window.tf) {
                const tfScript = document.createElement('script');
                tfScript.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js';
                document.head.appendChild(tfScript);
                await new Promise(resolve => tfScript.onload = resolve);
            }
            
            // Load Pose Detection
            if (!window.poseDetection) {
                document.head.appendChild(pdScript);
                await new Promise(resolve => pdScript.onload = resolve);
            }
           
            
            // Update React state for future clicks, but use 'net' for NOW
            setSystem(prev => ({ ...prev, detector: net }));
            addLog("AI Engine Ready");
        }

        const views = Object.keys(uploads).filter(k => uploads[k] && uploads[k].url);
        if(views.length === 0 && symptoms.length === 0) { addLog("Upload photo first"); return; }

        // Start the UI animation
        setStatus(prev => ({...prev, analyzing: true, logs: ["Constructing Digital Twin...", ...prev.logs]}));

        // FIX: Triple RAF + full 2s yield (no bottom snag)
        await new Promise(r => {
            requestAnimationFrame(() => { // Paint #1: Class hits
                requestAnimationFrame(() => { // Paint #2: Line starts
                    requestAnimationFrame(() => { // Paint #3: Full keyframes lock
                        setTimeout(r, 2000); // 2s: Complete cycle + buffer (smooth land)
                    });
                });
            });
        });

        let scores = { head: 100, shoulders: 100, spine: 100, gait: 100, hip: 100 };
        
        try {
            for(const view of views) {
                const img = uploadRefs[view].current;
                if(!img || img.naturalWidth === 0) continue;

                // USE 'net', NOT 'system.detector'
                const poses = await net.estimatePoses(img, { 
                    maxPoses: 1, 
                    flipHorizontal: false 
                });

                if(poses.length > 0) {
                    const keypoints = poses[0].keypoints;
                    drawSkeleton(keypoints, view); 

// --- SOPHISTICATED MULTI-METRIC BIOMECHANICAL GRADING ENGINE (V2) ---
let headScore = 100, shoulderScore = 100, spineScore = 100, hipScore = 100, gaitScore = 100;

if (view === 'side' || view === 'back') {
    const shoulder = keypoints[12];  // right shoulder
    const ear = keypoints[8];        // right ear (or closest)
    const hip = keypoints[24];
    const knee = keypoints[26];
    const ankle = keypoints[28];
    const nose = keypoints[0];

    if (shoulder && ear && hip && knee && ankle && nose) {
        const torsoHeight = Math.abs(hip.y - shoulder.y) || 0.3;  // Avoid divide by zero

        // Normalize distances to torso height more aggressively
        // Forward Head - very strict (real ideal is <0.05 ratio)
        const fhpDistance = Math.abs(ear.x - shoulder.x);
        const fhpRatio = fhpDistance / torsoHeight;
        if (fhpRatio > 0.08) headScore -= 50;
        else if (fhpRatio > 0.05) headScore -= 35;
        else if (fhpRatio > 0.03) headScore -= 20;

        // Nose forward (rounded shoulders proxy)
        const noseShift = Math.abs(nose.x - shoulder.x) / torsoHeight;
        if (noseShift > 0.10) headScore -= 40;
        else if (noseShift > 0.06) headScore -= 25;

        // Anterior Pelvic Tilt
        const aptDistance = Math.abs(hip.x - shoulder.x);
        const aptRatio = aptDistance / torsoHeight;
        if (aptRatio > 0.10) hipScore -= 50;
        else if (aptRatio > 0.07) hipScore -= 35;
        else if (aptRatio > 0.04) hipScore -= 20;

        // Knee alignment
        const kneeOffset = Math.abs(knee.x - ankle.x);
        const lowerLegHeight = Math.abs(knee.y - ankle.y) || 0.2;
        const kneeRatio = kneeOffset / lowerLegHeight;
        if (kneeRatio > 0.15) gaitScore -= 45;
        else if (kneeRatio > 0.10) gaitScore -= 30;

        // Plumb line - strictest check
        const refX = (shoulder.x + hip.x) / 2;  // Use mid-torso as reference for better accuracy
        const plumbDevs = [
            Math.abs(ear.x - refX),
            Math.abs(nose.x - refX),
            Math.abs(knee.x - refX),
            Math.abs(ankle.x - refX)
        ];
        const avgPlumb = plumbDevs.reduce((a,b) => a + b, 0) / plumbDevs.length / torsoHeight;
        if (avgPlumb > 0.08) spineScore -= 55;
        else if (avgPlumb > 0.05) spineScore -= 40;
        else if (avgPlumb > 0.03) spineScore -= 25;
    }
}

if (view === 'front') {
    const lShoulder = keypoints[11], rShoulder = keypoints[12];
    const lHip = keypoints[23], rHip = keypoints[24];
    const lKnee = keypoints[25], rKnee = keypoints[26];
    const lAnkle = keypoints[27], rAnkle = keypoints[28];

    if (lShoulder && rShoulder && lHip && rHip) {
        const torsoHeight = Math.abs((lHip.y + rHip.y)/2 - (lShoulder.y + rShoulder.y)/2) || 0.4;

        const shoulderDiff = Math.abs(lShoulder.y - rShoulder.y) / torsoHeight;
        if (shoulderDiff > 0.04) shoulderScore -= 50;
        else if (shoulderDiff > 0.02) shoulderScore -= 30;

        const hipDiff = Math.abs(lHip.y - rHip.y) / torsoHeight;
        if (hipDiff > 0.04) hipScore -= 50;
        else if (hipDiff > 0.02) hipScore -= 30;

        // Knee variance stricter
        if (kneeAnkleVariance > 0.08) gaitScore -= 45;
        else if (kneeAnkleVariance > 0.05) gaitScore -= 30;
    }
}

// Symptom-based penalties (kept, but reduced weight since metrics are stronger now)
if (symptoms.includes('Neck Pain')) headScore -= 12;
if (symptoms.includes('Back Pain')) spineScore -= 12;
if (symptoms.includes('Knee Pain')) gaitScore -= 15;
if (symptoms.includes('Foot Pain')) gaitScore -= 10;

// Final bounded scores
scores = {
    head: Math.max(0, Math.min(100, headScore)),
    shoulders: Math.max(0, Math.min(100, shoulderScore)),
    spine: Math.max(0, Math.min(100, spineScore)),
    hip: Math.max(0, Math.min(100, hipScore)),
    gait: Math.max(0, Math.min(100, gaitScore))
};
                }
            }
        } catch(err) {
            console.error(err);
            addLog("System Error");
        }

        // Finalize
        if(symptoms.includes('Neck Pain')) scores.head -= 10;
        if(symptoms.includes('Back Pain')) scores.spine -= 10;
        if(symptoms.includes('Knee Pain')) scores.gait -= 15;

        const finalScore = Math.floor((scores.head + scores.shoulders + scores.spine + scores.gait + scores.hip) / 5);
        
        const newAudit = {
            date: new Date().toLocaleDateString(), score: Math.max(0, finalScore),
            head: { val: scores.head, grade: getGrade(scores.head) },
            shoulders: { val: scores.shoulders, grade: getGrade(scores.shoulders) },
            spine: { val: scores.spine, grade: getGrade(scores.spine) },
            gait: { val: scores.gait, grade: getGrade(scores.gait) },
            hip: { val: scores.hip, grade: getGrade(scores.hip) }
        };

        setAudit(newAudit);

        // Confetti Logic
        const confettiContainer = document.createElement('div');
        confettiContainer.style.position = 'fixed';
        confettiContainer.style.inset = '0';
        confettiContainer.style.pointerEvents = 'none';
        confettiContainer.style.zIndex = '100';
        document.body.appendChild(confettiContainer);

        for (let i = 0; i < 50; i++) {
            const c = document.createElement('div');
            c.className = 'confetti';
            c.style.left = Math.random() * 100 + 'vw';
            c.style.background = ['#22d3ee', '#06b6d4', '#0891b2'][Math.floor(Math.random() * 3)];
            c.style.animationDelay = Math.random() * 3 + 's';
            confettiContainer.appendChild(c);
        }
        setTimeout(() => confettiContainer.remove(), 4000);

        setHistory([newAudit, ...history]);
        setStatus(prev => ({ ...prev, analyzing: false }));
        addLog(`Scan Complete. Score: ${finalScore}`);
        generateProgram();
        addLog("Protocol Ready — Check right panel");
        setShowProtocolButton(true);
    };
               // --- HYPER-PERSONALIZED STRATIFIED ENGINE (Final Fix) ---
       const generateProgram = () => {
    if (!audit) return;

    const totalSessions = history.length;
    let currentPhase = 1;
    if (totalSessions > 30) currentPhase = 4;
    else if (totalSessions > 15) currentPhase = 3;
    else if (totalSessions > 5) currentPhase = 2;

    // Build full pool respecting user preferences
    let pool = EXERCISE_DB.filter(ex => {
        if (!useEquipment && ex.equipment === 'required') return false;
        if (userPrefs.noEquipment && ex.equipment === 'required') return false;
        if (userPrefs.lowImpact && (ex.pattern.includes('power') || ex.pattern.includes('rhythmic'))) return false;
        if (userPrefs.noJumps && (ex.id.includes('hop') || ex.id.includes('bounce'))) return false;
        return true; // Allow ALL phases — we'll handle variety below
    });

    // --- ROOT-CAUSE CHAINING: Force include fixes for detected biomechanical faults ---
    const mustInclude = new Set(); // Exercises that MUST be in protocol

    if (audit) {
        // Forward Head / Tech Neck chain
        if (audit.head.val < 85 || symptoms.includes('Neck Pain')) {
            mustInclude.add('head_loading');
            mustInclude.add('chest_opener');
            mustInclude.add('diaphragm_breath');
            addLog("🔗 Forward Head Chain Activated");
        }

        // Pelvic Tilt / Hip Compensation chain
        if (audit.hip.val < 85) {
            mustInclude.add('split_squat');
            mustInclude.add('plantar_release');
            addLog("🔗 Pelvic/Hip Chain Activated");
        }

        // Spinal Compression / Poor Alignment chain
        if (audit.spine.val < 85 || symptoms.includes('Back Pain')) {
            mustInclude.add('spinal_wave');
            mustInclude.add('inversion_hang');
            addLog("🔗 Spinal Decompression Chain Activated");
        }

        // Foot Collapse / Gait chain
        if (audit.gait.val < 85 || symptoms.includes('Knee Pain') || symptoms.includes('Foot Pain')) {
            mustInclude.add('towel_curl');
            mustInclude.add('hyperarch');
            addLog("🔗 Foot-Gait Chain Activated");
        }
    }

    const criticalRegions = new Set();
    if (audit) {
        if (audit.head.grade === 'F' || audit.head.grade === 'D' || symptoms.includes('Neck Pain')) criticalRegions.add('head');
        if (audit.spine.grade === 'F' || audit.spine.grade === 'D' || symptoms.includes('Back Pain')) criticalRegions.add('spine');
        if (audit.shoulders.grade === 'F' || audit.shoulders.grade === 'D') criticalRegions.add('shoulders');
        if (audit.hip.grade === 'F' || audit.hip.grade === 'D') criticalRegions.add('hip');
        if (audit.gait.grade === 'F' || audit.gait.grade === 'D' || symptoms.includes('Knee Pain') || symptoms.includes('Foot Pain')) criticalRegions.add('gait');
    }

    const selected = [];
    const usedIds = new Set();
// Force-include root-cause fixes first
    mustInclude.forEach(id => {
        const ex = EXERCISE_DB.find(e => e.id === id);
        if (ex && !usedIds.has(id)) {
            selected.push(ex);
            usedIds.add(id);
        }
    });

    // Only ban across different days — allows unlimited regenerates today
    const today = new Date().toDateString();
    const bannedToday = new Set();
    Object.keys(exerciseHistory).forEach(id => {
        const hist = exerciseHistory[id];
        if (hist?.lastUsed && hist.lastUsed !== today) {
            const daysSince = (Date.now() - new Date(hist.lastUsed)) / 86400000;
            if (daysSince < 5) bannedToday.add(id);
        }
    });
    pool = pool.filter(ex => !bannedToday.has(ex.id));

    // Add max 1 critical fix if needed
    if (criticalRegions.size > 0 && pool.length > 0) {
        const critical = pool.filter(ex => criticalRegions.has(ex.target_grade));
        if (critical.length > 0) {
            const chosen = critical[Math.floor(Math.random() * critical.length)];
            selected.push(chosen);
            usedIds.add(chosen.id);
        }
    }

    // Pure maximum variety — aggressive shuffle
    let variety = pool.filter(ex => !usedIds.has(ex.id));
    for (let i = 0; i < 5; i++) { // 5x shuffle = true chaos
        variety.sort(() => Math.random() - 0.5);
    }

    // Fill to 6
    while (selected.length < 6 && variety.length > 0) {
        selected.push(variety.shift());
    }

    // Emergency fallback — should never trigger
    if (selected.length < 6) {
        const emergency = EXERCISE_DB.filter(ex => !usedIds.has(ex.id));
        emergency.sort(() => Math.random() - 0.5);
        while (selected.length < 6 && emergency.length > 0) {
            selected.push(emergency.shift());
        }
    }

    // Build final routine with level progression
    const routine = selected.map(ex => {
        const hist = exerciseHistory[ex.id] || {};
        let levelIdx = 0;

        if (hist.lastRating === 'easy') {
            levelIdx = Math.min(ex.levels.length - 1, (hist.lastLevel || 0) + 1);
        } else if (hist.lastRating === 'hard') {
            levelIdx = Math.max(0, (hist.lastLevel || 0) - 1);
        } else if (hist.lastLevel !== undefined) {
            levelIdx = hist.lastLevel;
        } else if (audit && (audit[ex.target_grade]?.grade === 'A' || audit[ex.target_grade]?.grade === 'B')) {
            levelIdx = Math.min(2, ex.levels.length - 1);
        }

        const level = ex.levels[levelIdx] || ex.levels[0];

        // Update history only with today's date
        setExerciseHistory(prev => ({
            ...prev,
            [ex.id]: {
                lastUsed: today,
                lastLevel: levelIdx,
                lastRating: prev[ex.id]?.lastRating,
                goodStreaks: prev[ex.id]?.goodStreaks || 0
            }
        }));

        return {
            ...level,
            id: ex.id,
            baseTitle: ex.title,
            reason: "Ultra-Fresh Personalized",
            allLevels: ex.levels,
            currentLevelIdx: levelIdx
        };
    });

    setActiveProgram(routine);
    setDailyRoutine([
        { time: "Morning", task: routine[0]?.name || "Activation", completed: false },
        { time: "Mid-Day", task: routine[3]?.name || "Focus", completed: false },
        { time: "Evening", task: routine[5]?.name || "Integration", completed: false }
    ]);

    addLog("Protocol Generated – Maximum Variety Achieved");
};
        // --- PRESET LOADER ---
const loadPreset = (presetName) => {
    const exerciseIds = PRESET_PROTOCOLS[presetName];
    if (!exerciseIds || exerciseIds.length === 0) return;

    let routine = [];

    // Special case: Head-Loaded Power Flow = all progressions of head_loading
    if (presetName === "Head-Loaded Power Flow") {
        const headEx = EXERCISE_DB.find(e => e.id === "head_loading");
        if (headEx) {
            routine = headEx.levels.map((level, idx) => ({
                ...level,
                name: `Head-Loaded Power Flow - Step ${idx + 1}: ${level.name}`,
                id: headEx.id,
                baseTitle: "Head-Loaded Power Flow",
                reason: presetName,
                allLevels: headEx.levels,
                currentLevelIdx: idx,
                duration: level.duration || 90
            }));
        }
    } else {
        // All other presets: one exercise per ID, using level 1 or 2
        routine = exerciseIds.map((id, overallIdx) => {
            const ex = EXERCISE_DB.find(e => e.id === id);
            if (!ex) return null;
            
            const levelIdx = ex.levels.length > 1 ? 1 : 0;
            const level = ex.levels[levelIdx];
            
            return {
                ...level,
                name: `${presetName} - ${overallIdx + 1}: ${level.name || ex.title}`,
                id: ex.id,
                baseTitle: presetName,
                reason: presetName,
                allLevels: ex.levels,
                currentLevelIdx: levelIdx,
                duration: level.duration || 90
            };
        }).filter(Boolean);
    }
    
    setActiveProgram(routine);
    addLog(`Loaded ${presetName} — ${routine.length} movements`);
};
        // NEW: Update Goal Handler
        const updateGoal = () => setShowGoalSetter(true);

        return (
            <div className="workspace bg-slate-950 text-white selection:bg-cyan-500 selection:text-black">
	{cameraActive && <CameraCapture onClose={() => setCameraActive(null)} onCapture={(url) => {
                    setUploads(prev => ({ ...prev, [cameraActive]: { url, analyzed: false } }));
                    setCameraActive(null);
                    addLog(`Captured ${cameraActive} view via Camera`);
                }} />}
                {showReader && <ReaderMode item={showReader} onClose={() => setShowReader(null)} />}
                {showGoalSetter && <GoalSetter currentGoal={currentGoal} onSave={saveGoal} onClose={() => setShowGoalSetter(false)} />}
                {showShare && <ShareReport audit={audit} onClose={() => setShowShare(false)} />}
                <div className="viewport">
<div className="text-center mb-8 px-6">
    <h1 className="text-4xl md:text-5xl font-black text-white mb-4 tracking-tight">
        Fix Your Posture in 60 Seconds
    </h1>
    <p className="text-lg text-slate-300 mb-6 max-w-2xl mx-auto">
        Upload 1-3 photos (front, side, back) → Get an instant biomechanical analysis + personalized training protocol based on decentralized movement methods.
    </p>
    <div className="text-sm text-cyan-400 font-bold">
        Completely free • Used by thousands of athletes & desk workers
    </div>
</div>
                    {/* HEADER NAV - ENHANCED with Progress Tab */}
                    <div className="flex justify-between items-center mb-6 no-print">
                        <div className="flex gap-4">
                            <div onClick={() => setTab('dashboard')} className={`tab-btn ${tab==='dashboard'?'active':''}`}>SCANNER</div>
                            <div onClick={() => setTab('progress')} className={`tab-btn ${tab==='progress'?'active':''}`}><Icons.Target /> PROGRESS</div>
                            <div onClick={() => setTab('academy')} className={`tab-btn ${tab==='academy'?'active':''}`}><Icons.Book /> ACADEMY</div>
                        </div> {/* Mobile floating button - only shows on phone after you have a scan */}
{window.innerWidth < 768 && audit && (
    <button
        onClick={() => document.querySelector('.glass-panel').scrollIntoView({ behavior: 'smooth' })}
        className="fixed bottom-6 right-6 z-50 bg-cyan-600 hover:bg-cyan-500 text-white rounded-full p-4 shadow-2xl shadow-cyan-900/50 flex items-center justify-center"
        style={{ width: '60px', height: '60px' }}
    >
        <Icons.ArrowUp />
    </button>
)}
                        {tab === 'dashboard' && <button 
    onClick={runAnalysis} 
    disabled={status.analyzing}
    className="btn-primary w-auto shadow-lg shadow-cyan-900/50 text-lg py-4 px-8"
>
    {status.analyzing 
        ? "ANALYZING POSE..." 
        : (uploads.front || uploads.side || uploads.back || symptoms.length > 0)
            ? "FREE ANALYSIS"
            : "SELECT SYMPTOMS OR UPLOAD PHOTO"
    }
</button>}
                    </div>
                    
                    {tab === 'dashboard' ? (
                        <>
                            {/* NEW: SYMPTOM INTAKE */}
                            <div className="mb-6 no-print">
                                <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">Pain / Symptoms (Select all that apply)</div>
                                <div className="flex flex-wrap gap-2">
                                    {['Neck Pain', 'Back Pain', 'Knee Pain', 'Foot Pain'].map(sym => (
                                        <div key={sym} onClick={() => toggleSymptom(sym)} className={`symptom-chip ${symptoms.includes(sym) ? 'selected' : ''}`}>
                                            {symptoms.includes(sym) && <Icons.Check />} {sym}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            <div className="upload-grid flex-1">
{['front', 'side', 'back'].map(view => (
    <div key={view} className={`upload-slot ${uploads[view] ? 'active' : ''} ${status.analyzing ? 'analyzing' : ''}`}>
       {uploads[view] ? (
    <div className="w-full h-full relative">
        <img 
            ref={el => { if(el) uploadRefs[view].current = el; }} 
            src={uploads[view].url} 
            className="absolute inset-0 w-full h-full object-cover opacity-0" 
            crossOrigin="anonymous" 
            alt={`${view} view`}
        />
        <canvas 
            id={`canvas-${view}`} 
            className="absolute inset-0 w-full h-full object-cover pointer-events-none z-10"
        />
        <div className="absolute top-2 right-2 bg-emerald-500 text-black text-[10px] font-bold px-2 py-1 rounded flex items-center gap-1 z-20"><Icons.Check/> ANALYZED</div>
        <div className="absolute inset-0 bg-black/40 opacity-0 hover:opacity-100 transition-opacity flex items-center justify-center text-xs font-bold uppercase tracking-widest z-20 cursor-pointer" onClick={() => uploadRefs[view].current.click()}>
            Click to Change
        </div>
    </div>
) : (
    <div className="flex flex-col items-center gap-6">
    <div className="text-6xl opacity-30">📸</div>
    <div className="text-center">
        <div className="text-lg font-black text-white mb-2 uppercase">{view} View</div>
        <div className="text-sm text-slate-400">Stand straight, arms at sides</div>
    </div>
    <div className="flex gap-4">
        <button onClick={() => uploadRefs[view].current.click()} className="px-6 py-3 bg-cyan-600 hover:bg-cyan-500 rounded-lg font-bold text-sm">
            Upload Photo
        </button>
        <button onClick={() => setCameraActive(view)} className="px-6 py-3 bg-slate-700 hover:bg-slate-600 rounded-lg font-bold text-sm">
            Use Camera
        </button>
    </div>
</div>
)}
<div className="scanner-line"></div>
<input type="file" ref={uploadRefs[view]} className="hidden" accept="image/*" onChange={(e) => handleFile(e, view)} />
    </div>
))}
                            </div>
                            <div className="mt-4 flex gap-4 text-[10px] font-mono text-slate-500 bg-slate-900/50 p-2 rounded border border-slate-800 no-print">{status.logs.map((l,i) => <span key={i}>{l}</span>)}</div>
                        </>
                    ) : tab === 'progress' ? (
                        <div className="p-6 space-y-6 overflow-y-auto">
                            <div className="text-center">
                                <h2 className="text-2xl font-black text-white mb-2">Your Progress Journey</h2>
                                <p className="text-slate-400">Track streaks, goals, and milestones to stay motivated.</p>
                            </div>
                            <StreakTracker streakDays={streakDays} onReset={resetStreak} />
                            <GoalTracker currentScore={audit?.score || history[0]?.score || 0} targetScore={currentGoal.target} progress={currentGoal} onUpdateGoal={updateGoal} />
                            <div className="bg-slate-900/50 border border-slate-700 rounded-lg p-4">
                                <h3 className="text-sm font-bold text-white mb-3 flex items-center gap-2"><Icons.Award /> Achievements</h3>
                                <div className="space-y-2">
                                    {achievements.map(a => (
                                        <div key={a.id} className={`flex items-center gap-2 p-2 rounded ${a.unlocked ? 'bg-emerald-900/30 border border-emerald-700/50' : 'bg-slate-800/50 text-slate-500'}`}>
                                            {a.icon} <span className="text-xs">{a.name}</span> {a.unlocked && <Icons.Check className="text-emerald-400" />}
                                        </div>
                                    ))}
                                </div>
                            </div>
                            {audit && (
                                <button onClick={() => setShowShare(true)} className="w-full py-3 bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 text-white font-bold rounded uppercase text-xs tracking-widest shadow-lg shadow-cyan-900/20 flex items-center justify-center gap-2 no-print">
                                    <Icons.Share /> Share This Report
                                </button>
                            )}
                        </div>
                    ) : (
                        <KnowledgeBase onOpen={setShowReader} />
                    )}
                </div>
                
                {/* RIGHT PANEL - The Value Engine */}
 {/* Removed 'flex flex-col' so it doesn't squeeze the content */}
<div className="glass-panel flex flex-col"> 
    {/* Removed 'shrink-0' because we aren't flexing anymore */}
    <div className="p-6 border-b border-slate-800 bg-slate-900/50 flex-shrink-0 overflow-y-auto max-h-96

">
                        <div className="flex justify-between items-start mb-2"><div className="text-[10px] font-bold text-cyan-500 uppercase tracking-widest">Structural Score</div></div>
                        <div className={`text-6xl font-black ${!audit || audit.score > 90 ? 'text-emerald-400' : audit.score > 80 ? 'text-blue-500' : audit.score > 70 ? 'text-yellow-400' : audit.score > 60 ? 'text-orange-400' : 'text-red-400'} tracking-tighter`}>{audit ? audit.score : (history[0]?.score || '--')}</div> {/* MY PROTOCOL BUTTON - Appears only after scan */}
{showProtocolButton && activeProgram && (
    <div className="mt-6 animate-popIn">
        <button 
            onClick={() => setActiveProgram(activeProgram)}
            className="w-full py-5 bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 text-white font-black text-lg rounded-xl uppercase tracking-widest shadow-2xl shadow-cyan-900/60 flex items-center justify-center gap-3 transition-all hover:scale-105"
        >
            <Icons.List /> OPEN MY PROTOCOL
        </button>
    </div>
)}
                        <div className="mt-4 flex gap-2 no-print flex-wrap">
                            <button onClick={runAnalysis} disabled={status.analyzing} className="px-2 py-1 bg-slate-800 hover:bg-slate-700 text-white rounded text-[10px] font-bold flex items-center gap-2"><Icons.Scan/> RESCAN</button>
                            <button onClick={() => window.print()} className="px-2 py-1 bg-slate-800 hover:bg-slate-700 text-white rounded text-[10px] font-bold flex items-center gap-2"><Icons.Print/> REPORT</button>
                            <div className="px-2 py-1 bg-slate-800 text-slate-400 rounded text-[10px] font-bold flex items-center gap-2"><Icons.History/> {history.length} SCANS</div> {/* MY PROTOCOL BUTTON - MOVED UP SO IT'S ALWAYS VISIBLE */}
{audit ? (
    <div className="mt-6">
        <div className="flex bg-slate-900 p-1 rounded-lg border border-slate-700 mb-4">
            <button onClick={() => setUseEquipment(false)} className={`flex-1 py-2 text-[10px] font-bold rounded transition-all ${!useEquipment ? 'bg-slate-800 text-white shadow-sm' : 'text-slate-500 hover:text-slate-300'}`}>
                BODYWEIGHT ONLY
            </button>
            <button onClick={() => setUseEquipment(true)} className={`flex-1 py-2 text-[10px] font-bold rounded transition-all ${useEquipment ? 'bg-cyan-600 text-white shadow-sm' : 'text-slate-500 hover:text-slate-300'}`}>
                ALL EQUIPMENT
            </button>
        </div>

        <button 
            onClick={generateProgram} 
            className="w-full py-5 bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 text-white font-black text-lg rounded-xl uppercase tracking-widest shadow-2xl shadow-cyan-900/40 flex items-center justify-center gap-3 transition-all hover:scale-105 no-print"
        >
            <Icons.List /> MY PROTOCOL
        </button>
    </div>
) : null}
                        </div>
                        
                        {/* DAILY HABIT & BADGES - Always Visible */}
                        <div className="mt-4 space-y-2">
                            {achievements.some(a => a.unlocked) && <div className="flex gap-2 overflow-x-auto pb-2 no-scrollbar">
                                {achievements.filter(a=>a.unlocked).map(a => (
                                    <div key={a.id} className="bg-gradient-to-r from-yellow-900/40 to-amber-900/40 border border-yellow-700/30 px-3 py-1 rounded text-[10px] text-yellow-200 flex items-center gap-1 whitespace-nowrap"><Icons.Check/> {a.name}</div>
                                ))}
                            </div>}
                            
                            {dailyRoutine.length > 0 && (
                                <div className="bg-slate-900/50 border border-slate-700 rounded-lg p-4">
                                    <div className="text-[10px] font-bold text-slate-500 uppercase mb-3">Today's Daily Habits</div>
                                    <div className="space-y-2">
                                        {dailyRoutine.map((t, i) => (
                                            <div key={i} onClick={() => toggleDailyTask(i)} className={`task-card ${t.completed ? 'completed' : ''}`}>
                                                <div className="task-check">{t.completed && <Icons.Check/>}</div>
                                                <div className="flex-1">
                                                    <div className="text-xs font-bold text-white">{t.time}</div>
                                                    <div className="text-[10px] text-slate-400">{t.task}</div>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                        
{/* MODIFIED: Presets are now ALWAYS visible (Zero Friction) */}
<div className="mt-6">
    <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">Quick Protocols</div>
    <div className="grid grid-cols-3 gap-1 mb-4">
        {Object.keys(PRESET_PROTOCOLS).map(p => (
            <button key={p} onClick={() => loadPreset(p)} className="protocol-badge">{p}</button>
        ))}
    </div>
</div>

{/* NEW: User Preferences Toggle */}
<div className="mt-4">
    <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">My Preferences</div> <div className="mt-2 p-2 bg-slate-900/50 rounded border border-slate-700">
    <div className="text-[9px] font-bold text-slate-500 uppercase mb-1">This Week's Theme</div>
    <div className="text-xs font-bold text-cyan-400 capitalize">{currentTheme} Focus</div>
</div>
    <div className="space-y-1">
        <label className="flex items-center gap-2 text-[9px] text-slate-400 cursor-pointer">
            <input type="checkbox" checked={userPrefs.lowImpact} onChange={(e) => setUserPrefs(p => ({...p, lowImpact: e.target.checked}))} className="w-3 h-3 rounded text-cyan-500" />
            Low Impact (Skip Explosives)
        </label>
        <label className="flex items-center gap-2 text-[9px] text-slate-400 cursor-pointer">
            <input type="checkbox" checked={userPrefs.noJumps} onChange={(e) => setUserPrefs(p => ({...p, noJumps: e.target.checked}))} className="w-3 h-3 rounded text-cyan-500" />
            No Jumps/Plyos
        </label>
        <label className="flex items-center gap-2 text-[9px] text-slate-400 cursor-pointer">
            <input type="checkbox" checked={userPrefs.noEquipment} onChange={(e) => setUserPrefs(p => ({...p, noEquipment: e.target.checked}))} className="w-3 h-3 rounded text-cyan-500" />
            No Equipment
        </label>
    </div>
</div>

                        
                       <div className="h-4"></div>
                    </div> 
                    {/* NEW: Tabs for Body vs Data */}
                    <div className="flex border-b border-slate-800 bg-slate-900/30 flex-shrink-0">
                        <button onClick={()=>setRightPanelTab('data')} className={`flex-1 py-3 text-sm font-bold uppercase ${rightPanelTab==='data' ? 'text-cyan-400 border-b-2 border-cyan-400' : 'text-slate-500'}`}>Report</button>
                        <button onClick={()=>setRightPanelTab('twin')} className={`flex-1 py-3 text-sm font-bold uppercase ${rightPanelTab==='twin' ? 'text-cyan-400 border-b-2 border-cyan-400' : 'text-slate-500'}`}>Digital Twin</button>
                    </div>

                    <div className="flex-1 p-6 overflow-y-auto bg-slate-950/30">
                        {rightPanelTab === 'data' ? (
                            <>
                                <TrendGraph history={history} />
                                <div className="space-y-4">
                                    <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">Fascial Integrity Report</div>
                                    {!audit && !history[0] ? <div className="text-center text-slate-600 text-xs py-10">Upload photos to begin analysis</div> : (audit || history[0]) && [
                                        { label: "Superficial Back Line", sub: "Posture / Extension", data: (audit||history[0]).head, unit: "%", risk: "Restriction" },
                                        { label: "Deep Front Arm Line", sub: "Shoulder Stability", data: (audit||history[0]).shoulders, unit: "°", risk: "Tightness" },
                                        { label: "Deep Front Line", sub: "Core Foundation", data: (audit||history[0]).spine, unit: "%", risk: "Compression" },
                                        { label: "Lateral Line", sub: "Hip & Side Balance", data: (audit||history[0]).hip, unit: "°", risk: "Asymmetry" },
                                        { label: "Spiral Line", sub: "Rotational Power", data: (audit||history[0]).gait, unit: "px", risk: "Weak Recoil" }
                                    ].map((m, i) => (
                                        <div key={i} className="bg-slate-900/50 border border-slate-700/50 p-4 rounded-lg hover:border-slate-600 transition-all group relative overflow-hidden">
                                            <div className="flex justify-between items-start mb-2">
                                                <div>
                                                    <div className="font-bold text-xs text-slate-200">{m.label}</div>
                                                    <div className="text-[9px] text-cyan-500 font-semibold">{m.sub}</div>
                                                </div>
                                                <div className={`font-black text-sm ${m.data.grade === 'F' ? 'text-red-400' : m.data.grade === 'D' ? 'text-orange-400' : m.data.grade === 'C' ? 'text-yellow-400' : m.data.grade === 'B' ? 'text-blue-500' : 'text-emerald-400'}`}>{m.data.grade}</div></div>
                                            <div className="w-full bg-slate-800 h-1.5 rounded-full overflow-hidden mb-2"><div className={`h-full ${m.data.grade === 'F' ? 'bg-red-500' : m.data.grade === 'D' ? 'bg-orange-500' : m.data.grade === 'C' ? 'bg-yellow-500' : m.data.grade === 'B' ? 'bg-blue-500' : 'bg-emerald-500'}`} style={{width: `${Math.min(100, Math.max(10, 100 - m.data.val))}%`}}></div></div>
                                            <div className="flex justify-between items-center"><div className="text-[10px] text-slate-500 font-mono">INTEGRITY: {m.data.val}{m.unit}</div>{m.data.grade !== 'A' && <div className="text-[9px] font-bold text-red-400 bg-red-900/20 px-2 py-0.5 rounded border border-red-900/30">{m.risk}</div>}</div>
                                        </div>
                                    ))}
                                </div>
                            </>
                        ) : (
                            <div className="h-full flex flex-col gap-6">
        {/* DIGITAL TWIN AVATAR — ALWAYS AT THE TOP */}
        <div className="bg-slate-900/60 rounded-2xl p-8 flex flex-col items-center justify-center border border-slate-700 shadow-2xl">
            <div className="text-lg font-black text-cyan-400 mb-6 uppercase tracking-widest">YOUR DIGITAL TWIN</div>
            <BioAvatar audit={audit || history[0]} symptoms={symptoms} onPartClick={(part) => handleChat(`Explain my ${part} grade`)} />
            <p className="text-sm text-slate-400 mt-6 text-center font-medium">Tap any body part for instant analysis</p>
        </div>

        {/* CHAT — NOW BELOW, SO NO SCROLLING NEEDED TO SEE AVATAR */}
        <div className="flex-1 bg-slate-900/40 rounded-2xl border border-slate-700 overflow-hidden shadow-xl">
            <AICoach audit={audit || history[0]} symptoms={symptoms} chatHistory={chatHistory} onSend={handleChat} />
        </div>
    </div>
                        )}
                    </div>
                </div>
                {activeProgram && <ProgramPlayer program={activeProgram} onClose={() => setActiveProgram(null)} onFeedback={handleFeedback} />}
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
</script></body>
</html>
